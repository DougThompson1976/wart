defcall list(l idx . ends)
  withs (idx    (range-start l idx)
         end    (if
                  !ends
                    (+ idx 1)
                  !car.ends
                    len.l
                  :else
                    (range-bounce l car.ends))
         slice  (list_range l idx end))
    if ends
      slice
      car.slice

defset list((l idx . ends) val)
  `(withs ($idx (range-start ,l ,idx)
           $end ,(if !ends
                   `(+ $idx 1)
                   `(if !,car.ends
                      len.,l
                      (range-bounce ,l ,car.ends)))
           $val ,(if ends val `(list ,val)))
      (list_splice ,l $idx $end $val))

def pos(x xs n)
  or= n 0
  if xs
    if (iso x car.xs)
      n
      (pos x cdr.xs (+ n 1))

def rpos(x xs n)
  aif (pos x rev.xs n)
    (- len.xs 1 it)

def predicate(x) :case list?.x
  (fn(_) (pos _ x))

def= car(l x)
  (set_car l x)

def= cdr(l x)
  (set_cdr l x)

def empty?(l)
  nil?.l

def blank?(l)
  (or nil?.l empty?.l)

def copy(x)
  if cons?.x
    (cons copy:car.x copy:cdr.x)
    x

def single?(x)
  (and cons?.x ~cdr.x)

def pair?(x)
  (and cons?.x
       cdr.x
       cons?:cdr.x
       ~cdr:cdr.x)

def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def lastcons(l)
  aif cdr.l
    lastcons.it
    l

def last(l)
  car:lastcons.l



def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def zipmax(a b)
  if (or a b)
    (cons (list car.a car.b)
          (zipmax cdr.a cdr.b))

def zip-flat(a b)
  if (and a b)
    `(,car.a ,car.b ,@(zip-flat cdr.a cdr.b))

def flatten(l acc)
  (if
    !l
      acc
    ~cons?.l
      (cons l acc)
    :else
      (flatten car.l (flatten cdr.l acc)))



def join args
  if args
    if car.args
      (cons car:car.args
            (join cdr:car.args @cdr.args))
      (join @cdr.args)

def keep(f seq)
  if seq
    if f:car.seq
      (cons car.seq (keep f cdr.seq))
      (keep f cdr.seq)

def rem(f seq)
  (keep complement:predicate.f seq)
alias skip rem

def some(f seq)
  if seq
    if (f car.seq)
      1
      (some f cdr.seq)

def all(f seq)
  (~some ~f seq)

alias any some
alias none ~some



def map(f . seqs)
  if (all present? seqs)
    (cons (f @(map car seqs))
          (map f @(map cdr seqs)))

def map(f seq . rest) :case no.rest
  if seq
    (cons (f car.seq)
          (map f cdr.seq))

def reduce(f xs init) ; f is a binary op
  (if
    !xs
      init
    ~cdr.xs
      car.xs ; f on one op is the identity function
    ~cddr.xs
      (f @xs)
    :else
      (reduce f (cons (f car.xs cadr.xs)
                      cddr.xs)))

def pairwise(xs)
  (zip xs cdr.xs)

def best(f seq)
  if seq
    ret winner car.seq
      each elem cdr.seq
        if (f elem winner)
          = winner elem



;; Internals

def range-bounce(l idx)
  if (< idx 0)
    (+ len.l idx)
    idx

def range-start(l idx)
  if !idx
    0
    (range-bounce l idx)

defcall list(l idx . ends)
  withs (idx (range-start l idx)
         end (if
               !ends
                 (+ idx 1)
               !car.ends
                 len.l
               :else
                 (range-bounce l car.ends)))
    ((if ends list_range car:list_range) l idx end)

defset list((l idx . ends) val)
  `(withs ($idx (range-start ,l ,idx)
           $end ,(if !ends
                   `(+ $idx 1)
                   `(if !,car.ends
                      len.,l
                      (range-bounce ,l ,car.ends)))
           $val ,(if ends val `(list ,val)))
      (list_splice ,l $idx $end $val))

def= car(l x)
  (set_car l x)

def= cdr(l x)
  (set_cdr l x)

def empty?(l)
  nil?.l

def blank?(l)
  (or nil?.l empty?.l)

def copy(x)
  if cons?.x
    (cons copy:car.x copy:cdr.x)
    x

def single?(x)
  (and cons?.x !cdr.x)

def join args
  if args
    if car.args
      (cons car:car.args
            (join cdr:car.args @cdr.args))
      (join @cdr.args)

def rem(f seq)
  if seq
    if (f car.seq)
      (rem f cdr.seq)
      (cons car.seq (rem f cdr.seq))

def keep(f seq)
  (rem ~f seq)

def map(f xs)
  if xs
    (cons (f car.xs)
          (map f cdr.xs))

def reduce(f xs)
  if cddr.xs
    (reduce f (cons (f car.xs cadr.xs)
                    cddr.xs))
    (f @xs)

def all(f xs)
  (and @(map f xs))

def some(f xs)
  (or @(map f xs))
alias any some
alias none ~some

def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def zip-flat(a b)
  if (and a b)
    `(,car.a ,car.b ,@(zip-flat cdr.a cdr.b))

def pairwise(xs)
  (zip xs cdr.xs)

def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def lastcons(l)
  aif cdr.l
    lastcons.it
    l



;; Internals

def range-bounce(l idx)
  (if (< idx 0)
    (+ len.l idx)
    idx)

def range-start(l idx)
  if !idx
    0
    (range-bounce l idx)

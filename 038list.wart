def bounce-index(x l)
  if (and x (< x 0))
    (+ len.l x)
    x

defcall list(l idx . end)
  (withs ($idx (if
                 no.idx
                   0
                 (< idx 0)
                   (+ len.l idx)
                 :else
                   idx)
          $end (if
                 no.end
                   (+ $idx 1)
                 (no car.end)
                   len.l
                 (< car.end 0)
                   (+ len.l car.end)
                 :else
                   car.end)
          maybe-car (if end id car))
    (maybe-car:list_range l $idx $end))

defset list((l idx . end) val)
  `(withs ($idx (if
                  no.,idx
                    0
                  (< ,idx 0)
                    (+ len.,l ,idx)
                  :else
                    ,idx)
           $end (if
                  ,no.end
                    (+ $idx 1)
                  (no ,car.end)
                    len.,l
                  (< ,car.end 0)
                    (+ len.,l ,car.end)
                  :else
                    ,car.end)
           $val ,(if end val `(list ,val)))
      (list_splice ,l $idx $end $val))

def= car(l x)
  (set_car l x)

def= cdr(l x)
  (set_cdr l x)

def empty?(l)
  nil?.l

def blank?(l)
  (or nil?.l empty?.l)

def rem(f seq)
  if seq
    if (f car.seq)
      (rem f cdr.seq)
      (cons car.seq (rem f cdr.seq))

def keep(f seq)
  (rem ~f seq)

def map(f xs)
  if xs
    (cons (f car.xs)
          (map f cdr.xs))

def reduce(f xs)
  if cddr.xs
    (reduce f (cons (f car.xs cadr.xs)
                    cddr.xs))
    (f @xs)

def all(f xs)
  (and @(map f xs))

def some(f xs)
  (or @(map f xs))
alias any some

def none(f xs)
  (not (some f xs))

def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def zip-flat(a b)
  if (and a b)
    `(,car.a ,car.b ,@(zip-flat cdr.a cdr.b))

def pairwise(xs)
  (zip xs cdr.xs)

def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def lastcons(l)
  aif cdr.l
    lastcons.it
    l

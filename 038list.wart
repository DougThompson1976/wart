defcall list(l idx . ends)
  withs (idx    (range-start l idx)
         end    (if
                  !ends
                    (+ idx 1)
                  !car.ends
                    len.l
                  :else
                    (range-bounce l car.ends))
         slice  (list_range l idx end))
    if ends
      slice
      car.slice

defset list((l idx . ends) val)
  `(withs ($idx (range-start ,l ,idx)
           $end ,(if !ends
                   `(+ $idx 1)
                   `(if !,car.ends
                      len.,l
                      (range-bounce ,l ,car.ends)))
           $val ,(if ends val `(list ,val)))
      (list_splice ,l $idx $end $val))

def pos(x xs n)
  or= n 0
  if xs
    if (iso x car.xs)
      n
      (pos x cdr.xs (+ n 1))

def predicate(x) :case list?.x
  (fn(_) (pos _ x))

def= car(l x)
  (set_car l x)

def= cdr(l x)
  (set_cdr l x)

def empty?(l)
  nil?.l

def blank?(l)
  (or nil?.l empty?.l)

def copy(x)
  if cons?.x
    (cons copy:car.x copy:cdr.x)
    x

def single?(x)
  (and cons?.x ~cdr.x)

def pair?(x)
  (and cons?.x
       cdr.x
       cons?:cdr.x
       ~cdr:cdr.x)

def join args
  if args
    if car.args
      (cons car:car.args
            (join cdr:car.args @cdr.args))
      (join @cdr.args)

def rem(f seq)
  if seq
    if (f car.seq)
      (rem f cdr.seq)
      (cons car.seq (rem f cdr.seq))

def keep(f seq)
  (rem ~f seq)

def map(f xs)
  if xs
    (cons (f car.xs)
          (map f cdr.xs))

def reduce(f xs)
  if cddr.xs
    (reduce f (cons (f car.xs cadr.xs)
                    cddr.xs))
    (f @xs)

def all(f xs)
  (if
    !xs
      1
    (f car.xs)
      (all f cdr.xs))

def some(f xs)
  if xs
    if (f car.xs)
      1
      (some f cdr.xs)

alias any some
alias none ~some

def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def zip-flat(a b)
  if (and a b)
    `(,car.a ,car.b ,@(zip-flat cdr.a cdr.b))

def pairwise(xs)
  (zip xs cdr.xs)

def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def lastcons(l)
  aif cdr.l
    lastcons.it
    l

def last(l)
  car:lastcons.l

def flatten(l acc)
  (if
    !l
      acc
    ~cons?.l
      (cons l acc)
    :else
      (flatten car.l (flatten cdr.l acc)))



;; Internals

def range-bounce(l idx)
  if (< idx 0)
    (+ len.l idx)
    idx

def range-start(l idx)
  if !idx
    0
    (range-bounce l idx)

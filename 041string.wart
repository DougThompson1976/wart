defcall string(s idx . ends)
  withs (idx (range-start s idx)
         end (if
               !ends
                 (+ idx 1)
               !car.ends
                 len.s
               :else
                 (range-bounce s car.ends)))
    (string_range s idx end)

defset string((s idx . ends) val)
  `(withs ($idx (range-start ,s ,idx)
           $end ,(if !ends
                   `(+ $idx 1)
                   `(if !,car.ends
                      len.,s
                      (range-bounce ,s ,car.ends))))
      (string_splice ,s $idx $end (or ,val "")))

defcoerce string symbol
  string_to_sym

def str args
  (w/outstring
    (each arg args pr.arg))

defcoerce symbol string
  str

def empty?(s) :case string?.s
  (iso "" s)

let $each each
  mac! each(var s . body)
    `(if string?.,s
       forlen $i ,s
         let ,var (,s $i)
           ,@body
       (,$each ,var ,s ,@body))

defcoerce string list
  (fn(_)
    (collect:each c _
      yield.c))

def <(a b) :case string?.a
  (string< a b)

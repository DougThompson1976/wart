(synonym newstring make-string)

(defcall string(s index)
  (elt s index))

(defset string(s index val)
  (setf (elt s index)
        val))



(def str(x)
  (as string x))

(defcoerce character string
  str^list)

(def join args :type '(character string)
  (apply 'concatenate 'string (map 'str args)))

(defcoerce cons string
  [if (all 'characterp _)
    (cl-coerce _ 'string) ; base case
    (apply 'join _)]) ; recurse



(def upcase(s)
  (map 'char-upcase s))
(def upcase(s) :case (not stringp.s)
  (upcase str.s))
(def upcase(s) :type 'null
  nil)
(def upcase(s) :type 'character
  (char-upcase s))

(def downcase(s)
  (map 'char-downcase s))
(def downcase(s) :case (not stringp.s)
  (downcase str.s))
(def downcase(s) :type 'null
  nil)
(def downcase(s) :type 'character
  (char-downcase s))



(def mkstr args
  (with-output-to-string(s)
    (each a args
      (princ upcase.a s))))

(def sym args
  (intern (apply 'mkstr args)))

(defcoerce string symbol
  'sym)
(defcoerce symbol string
  [map 'char-downcase (symbol-name _)])

(defcoerce symbol cons
  [as cons str._])
(defcoerce cons symbol
  intern^str)



(synonym letter alpha-char-p)
(synonym digit digit-char-p)
(def alphadig(c) (or (letter c) (digit c)))

(def punc(c)
  (in c #\. #\, #\; #\: #\! #\?))

(def whitec(c)
  (in c #\space #\newline #\tab #\return))

(def trim(s ? from 'both all-of '(#\space #\newline #\tab #\return))
  (case from
    'both   (string-trim all-of s)
    'front  (string-left-trim all-of s)
    'start  (string-left-trim all-of s)
    'back   (string-right-trim all-of s)
    'end    (string-right-trim all-of s)))

(def tokens(s ? sep 'whitec)
  (let rec (afn(cs toks tok)
             (if no.cs   (consif tok toks)
               (call testify.sep car.cs)   (self cdr.cs (consif tok toks) nil)
               :else  (self cdr.cs toks (cons car.cs tok))))
    (rev (map str^rev (call rec (as cons s) nil nil)))))

(def intersperse(x ys) :case (all [isa _ 'string] ys)
  (intersperse x ys :as 'string))

(synonym newstring make-string)

; can't defover string
(def stringify(x)
  (as string x))

(defcall string s
  [elt s _])

(defset string(s index val)
  (setf (elt s index)
        val))

(defcoerce standard-char string
  [as string list._])
(defcoerce base-char string
  [as string list._])

(defcoerce symbol string
  [map 'char-downcase (symbol-name _)])
(defcoerce symbol cons
  [as cons (as string _)])
(defcoerce cons symbol
  [intern (as string _)])

(defgeneric upcase(s)
  (as string (map 'char-upcase s)))
(defmethod upcase(s) null
  nil)
(defmethod upcase(s) symbol
  :coerce-to-cons)
(defmethod upcase(s) standard-char
  (char-upcase s))

(defgeneric downcase(s)
  (as string (map 'char-downcase s)))
(defmethod downcase(s) null
  nil)
(defmethod downcase(s) symbol
  :coerce-to-cons)
(defmethod downcase(s) standard-char
  (char-downcase s))

(defmethod join args string
  (apply 'concatenate 'string (map [as string _] args)))
(defmethod join args standard-char
  (apply 'concatenate 'string (map [as string _] args)))
(defmethod join args base-char
  (apply 'concatenate 'string (map [as string _] args)))

(def capitalize(word)
  (join (char-upcase word.0)
        (cut word 1)))



(def mkstr args
  (with-output-to-string(s)
    (each a args
      (princ upcase.a s))))

(def sym args
  (intern (apply 'mkstr args)))

(defcoerce string symbol
  'sym)



(synonym letter alpha-char-p)
(synonym digit digit-char-p)
(def alphadig(c) (or (letter c) (digit c)))

(def punc(c)
  (in c #\. #\, #\; #\: #\! #\?))

(def whitec(c)
  (in c #\space #\newline #\tab #\return))

(def trim(s ? where 'both test 'whitec)
  (withs (f   (testify test)
          p1  (pos ~f s))
    (if p1
      (cut s
           (if (in where 'front 'start 'both)
             p1
             0)
           (if (in where 'back 'end 'both)
             (call only.+ (rpos ~f s) 1)))
      "")))

(def tokens(s ? sep 'whitec)
  (let rec (afn(cs toks tok)
             (if no.cs   (cons tok toks)
                 (call testify.sep car.cs)   (self cdr.cs (cons tok toks) nil)
                 :else  (self cdr.cs toks (cons car.cs tok))))
    (rev (map [as string _]
              (map 'rev (call rec (as cons s) nil nil))))))

(def intersperse (x ys)
  (and ys (cons (car ys)
                (mappend [list x _] (cdr ys)))))

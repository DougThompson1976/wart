mac do1 $body
  `(ret $ret ,car.$body
     ,@cdr.$body)

def rem(f seq)
  if seq
    if (f car.seq)
      (rem f cdr.seq)
      (cons car.seq (rem f cdr.seq))

def keep(f seq)
  (rem ~f seq)

def map(f xs)
  if xs
    (cons (f car.xs)
          (map f cdr.xs))

def reduce(f xs)
  if cddr.xs
    (reduce f (cons (f car.xs cadr.xs)
                    cddr.xs))
    (f @xs)

def all(f xs)
  (and @(map f xs))

def some(f xs)
  (or @(map f xs))

assign any some

def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def pairwise(xs)
  (zip xs cdr.xs)



let $table table
  def table args
    ret t ($table)
      each (k v) pair.args
        (table_set t k v)



def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def len(l)
  if l
    (+ 1 (len cdr.l))
    0

def lastcons(l)
  aif cdr.l
    lastcons.it
    l



mac zap($f $x)
  `(assign ,$x (,$f ,$x))

mac push($x $xs)
  `(assign ,$xs (cons ,$x ,$xs))

mac pop($xs)
  `(do1
     (car ,$xs)
     (zap cdr ,$xs))



mac collect $body
  `(withs ($acc   (queue)
           yield  (fn(_)
                    (enq _ $acc)))
     ,@$body
     (car rep.$acc))

(test "list indexing works"
  :valueof (call '(1 2 3) 2)
  :should be 3)

(test "writing to list index works"
  :valueof (ret l '(1 2 3)
             (= l.1 34))
  :should be '(1 34 3))

(test "len works"
  :valueof (len '(1 2 3))
  :should be 3)

(test "len works on nil"
  :valueof (len nil)
  :should be 0)

(test "testify works with a list"
  :valueof (call (testify '(1 2 3)) 3)
  :should satisfy true_value)

(test "last has arc semantics rather than common lisp semantics"
  :valueof (last '(1 2 3))
  :should be 3)

(test "adjoin works"
  :valueof (adjoin 2 '(1 2 3))
  :should be '(1 2 3))

(test "adjoin works - 2"
  :valueof (adjoin 2 '(1 3 5))
  :should be '(2 1 3 5))

(test "alist works"
  :valueof (alist '((1 2) (3 4)))
  :should be '((1 . 2) (3 . 4)))

(test "dot works"
  :valueof (dot '(1 2))
  :should be '(1 . 2))



(test "mappend works"
  :valueof (mappend [list (* _ 10)] '(1 2 3))
  :should be '(10 20 30))

(test "intersperse works"
  :valueof (intersperse 3 '(1 2 4))
  :should be '(1 3 2 3 4))

(test "split works"
  :valueof (split '(1 2 3) 1)
  :should be '((1) (2 3)))

(test "all works"
  :valueof (all 'idfn '(1 2 3))
  :should be t)

(test "all works - 2"
  :valueof (all 'idfn '(1 nil 3))
  :should be nil)

(test "all works on strings"
  :valueof (all #\a "aaa")
  :should be t)

(test "mem works"
  :valueof (mem 'oddp '(2 4 5 6 7))
  :should be '(5 6 7))

(test "keep works"
  :valueof (keep 'oddp '(1 2 3))
  :should be '(1 3))

(test "keep works on strings"
  :valueof (keep [iso _ #\a] "abc")
  :should be "a")

(test "rem works"
  :valueof (rem 'oddp '(1 2 3))
  :should be '(2))

(test "rem works on strings"
  :valueof (rem #\a "abracadabra")
  :should be "brcdbr")

(test "trues works"
  :valueof (trues 'cdr '((1 2) (3) (4 5)))
  :should be '((2) (5)))

(test "cut works"
  :valueof (cut '(1 2 3 4) 2)
  :should be '(3 4))

(test "cut works on strings"
  :valueof (cut "abc" 1)
  :should be "bc")

(test "join still works"
  :valueof (join '(1) '(2 3))
  :should be '(1 2 3))

(test "join works on strings"
  :valueof (join "abc" "def")
  :should be "abcdef")

(test "join can handle nils, especially as last arg"
  :valueof (join nil '(3 4) nil '(5) '(6) nil)
  :should be '(3 4 5 6))

(test "join handles zero-args"
  :valueof (join)
  :should be nil)

(test "join handles all null args"
  :valueof (join nil nil nil)
  :should be nil)

(test "pos works"
  :valueof (pos 'c '(a b c d))
  :should be 2)

(test "pos works on strings"
  :valueof (pos #\c "abcd")
  :should be 2)

(test "pos takes index arg"
  :valueof (pos #\c "abcdc" 3)
  :should be 4)

(test "pos testifies"
  :valueof (pos 'oddp '(2 4 5 6 7))
  :should be 2)



(test "map works"
  :valueof (map '1+ '(2 3 4))
  :should be '(3 4 5))

(test "map works on strings"
  :valueof (map 'char-upcase "abc")
  :should be "ABC")

(test "map works on primitives"
  :valueof (map 'char-upcase #\a)
  :should be #\A)

(wt-eval '(def map(f . seqs) :case (isa car.seqs 'footype)
            (apply 'map0 f (map0 'rep seqs))))
(test "map works on user-defined types"
  :valueof (map 'len (annotate 'footype '((2 3) (3 4 4 6))))
  :should be '(2 4))

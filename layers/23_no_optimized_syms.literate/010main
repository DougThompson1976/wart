:(before "End Main")
setup_nil();
load_file("init.wart");

:(code)
void load_file(const char* filename) {
  ifstream f(filename);
  if (f.fail()) return;
  run(f);
}

// evaluate all exprs in input, return value of last expr
cell* run(istream& in) {
  cell* result = NULL;
  do {
      result = eval(read(in));
  } while (!eof(in));
  return result;
}

cell* run(string s) {
  stringstream in(s);
  return run(in);
}

:(scenarios run)

:(scenario example_run)
(+ 1 1)
+eval: => 2

:(code)
// construct a tree of cells out of next expr in input
cell* read(istream& in) {
  return next_cell(in);
}

:(before "End Types")
extern struct cell* nil;

struct cell {
  cell* car;  // aliased to long or float
  cell* cdr;

  // ints save space on 64-bit platforms
  int type;
    #define CONS 0
    #define INTEGER 1
    #define SYMBOL 2
    #define STRING 3

  cell() :car(NULL), cdr(NULL), type(CONS) {}
  void init() {
    car=cdr=nil, type=CONS;
  }
};

:(code)
// cells are designed to minimize fragmentation on the heap
void test_cell_layout_constraints() {
  cell c;
  CHECK((sizeof(c.car)%4) == 0);
  CHECK((sizeof(c.cdr)%4) == 0);
  CHECK((sizeof(c.type)%4) == 0);

  CHECK(sizeof(long) <= sizeof(cell*));
  CHECK(sizeof(float) <= sizeof(cell*));
  CHECK(sizeof(size_t) <= sizeof(cell*));
}

cell* nil = new cell;
void setup_nil() {
  nil->car = nil->cdr = nil;
}
:(before "End Test Initialization")
setup_nil();
:(code)
void test_pointers_from_nil_are_always_nil() {
  CHECK_EQ(nil->car, nil);
  CHECK_EQ(nil->cdr, nil);
}

// helper: convert all exprs in input into cells
list<cell*> read_all(istream& in) {
  list<cell*> results;
  do {
      results.push_back(read(in));
  } while (!eof(in));
  return results;
}

:(scenarios read_all)

:(scenario read_nil)
()
+cell: nil

:(scenario read_nil2)
nil
+cell: nil

:(scenario read_integer)
34
+cell: num 34

:(scenario read_symbol)
a
+cell: sym a

:(scenario read_string)
"a"
+cell: string "a"

:(code)
ostream& operator<<(ostream& os, cell* c) {
  if (c == NULL) return os << "NULLNULLNULL";
  if (c == nil) return os << "nil";
  switch(c->type) {
  case CONS:
    if (car(c) == new_sym("'"))
      return os << car(c) << cdr(c);
    os << "(" << car(c);
    for (cell* curr = cdr(c); curr != nil; curr = cdr(curr)) {
      if (is_cons(curr))
        os << " " << car(curr);
      else
        os << " ... " << curr;
    }
    return os << ")";
  case INTEGER:
    return os << to_int(c);
  case SYMBOL:
    return os << to_string(c);
  case STRING:
    return os << "\"" << to_string(c) << "\"";
  default:
    cerr << "Can't print type " << c->type << '\n' << die();
    return os;
  }
}

void test_strings_and_syms_are_different() {
  cell* s = new_string("a");
  CHECK(s != new_sym("a"));
}

:(scenario read_handles_quoted_sym)
'a
+cell: sym '
+cell: sym a
+cell: 'a
:(code)
void test_read_handles_quoted_sym2() {
  list<cell*> result = read_all("'a");
  cell* c = result.front();
  CHECK_EQ(car(c), new_sym("'"));
  CHECK_EQ(cdr(c), new_sym("a"));
}

:(scenario read_handles_multiple_atoms)
34
35
+cell: num 34
+cell: num 35

:(scenario read_handles_form)
(34 35)
+cell: num 34
+cell: num 35
+cell/4: nil
+cell/3: (35)
+cell/2: (34 35)

:(code)
void test_build_handles_dotted_list() {
  read_all("(34 ... 35)");
  CHECK_TRACE_CONTENTS("cell", 2, "(34 ... 35)");
  CHECK_TRACE_CONTENTS("cell", 3, "num 35");
  CHECK_TRACE_CONTENTS("cell", /*any frame*/ "num 34num 35");
}

void test_build_handles_literal_ellipses() {
  list<cell*> result = read_all("'...");
  CHECK_TRACE_TOP("cell", "'...");
  cell *c = result.front();
  CHECK_EQ(car(c), new_sym("'"));
  CHECK_EQ(cdr(c), new_sym("..."));
}

void test_build_handles_nested_form() {
  read_all("(3 7 (33 23))");
  CHECK_TRACE_CONTENTS("cell", 2, "(3 7 (33 23))");
  CHECK_TRACE_CONTENTS("cell", 3, "(7 (33 23))");
  CHECK_TRACE_CONTENTS("cell", 4, "((33 23))");
  CHECK_TRACE_CONTENTS("cell", 5, "nil");
  CHECK_TRACE_CONTENTS("cell", /*any frame*/ "num 3num 7num 33num 23(33 23)");
}

void test_build_handles_strings() {
  read_all("(3 7 (33 \"abc\" 23))");
  CHECK_TRACE_CONTENTS("cell", 2, "(3 7 (33 \"abc\" 23))");
  CHECK_TRACE_CONTENTS("cell", /*any frame*/ "string \"abc\"");
}

void test_build_handles_syms() {
  read_all("(3 7 (33 \"abc\" 3de 23))");
  CHECK_TRACE_TOP("cell", "(3 7 (33 \"abc\" 3de 23))");
  CHECK_TRACE_CONTENTS("cell", 2, "(3 7 (33 \"abc\" 3de 23))");
  CHECK_TRACE_CONTENTS("cell", /*any frame*/ "sym 3de");
}

void test_build_handles_indented_wrapped_lines() {
  read_all("a\n  (a b c\n   d e)");
  CHECK_TRACE_TOP("cell", "sym a(a b c d e)");
  CHECK_TRACE_CONTENTS("cell", 2, "(a b c d e)");
  CHECK_TRACE_CONTENTS("cell", 3, "(b c d e)");
  CHECK_TRACE_CONTENTS("cell", 4, "(c d e)");
  CHECK_TRACE_CONTENTS("cell", 5, "(d e)");
  CHECK_TRACE_CONTENTS("cell", 6, "(e)");
  CHECK_TRACE_CONTENTS("cell", 7, "nil");
}



// evaluate tree of cells as code
cell* eval(cell* expr) {
  new_trace_frame("eval");
  if (!expr)
    RAISE << "eval: cell should never be NULL\n" << die();

  trace("eval") << expr;
  if (expr == nil) {
    trace("eval") << "nil branch";
    trace("eval") << "=> nil";
    return nil;
  }

  if (is_keyword_sym(expr)) {
    trace("eval") << "keyword sym";
    trace("eval") << "=> " << expr;
    return expr;
  }

  if (is_sym(expr)) {
    trace("eval") << "sym";
    cell* result = lookup(expr);
    trace("eval") << "=> " << result;
    return result;
  }

  if (is_atom(expr)) {
    trace("eval") << "literal";
    trace("eval") << "=> " << expr;
    return expr;
  }

  if (is_quoted(expr)) {
    trace("eval") << "quote";
    trace("eval") << "=> " << cdr(expr);
    return cdr(expr);
  }

  cell* result = eval_primitive(car(expr), cdr(expr));
  if (result) {
    trace("eval") << "compiled fn";
    trace("eval") << "=> " << result;
    return result;
  }

  // expr is a call
  cell* fn = eval(car(expr));
  if (!is_fn(fn))
    RAISE << "Not a call: " << expr << '\n'
        << "Perhaps you need to split the line in two.\n";

  // eval its args, create new bindings
  eval_bind_all(sig(fn), cdr(expr));

  // eval all forms in body, save result of final form
  for (cell* form = body(fn); form != nil; form=cdr(form))
    result = eval(car(form));
  trace("eval") << "=> " << result;
  return result;
}

cell* eval_primitive(cell* f, cell* args) {
  if (f == new_sym("fn")) {
    return new_cons(f, args);
  }

  if (f == new_sym("eval")) {
    cell* arg = eval(car(args));
    return eval(arg);
  }

  if (f == new_sym("if")) {
    cell* check = eval(car(args));
    return (check != nil) ? eval(car(cdr(args))) : eval(car(cdr(cdr(args))));
  }

  if (f == new_sym("not")) {
    cell* arg = eval(car(args));
    return (arg == nil) ? new_num(1) : nil;
  }

  if (f == new_sym("=")) {
    cell* x = eval(car(args));
    cell* y = eval(car(cdr(args)));
    if (x == nil && y == nil)
      return new_num(1);
    else if (x == nil || y == nil)
      return nil;
    else if (x == y)
      return x;
    else if (is_string(x) && is_string(y) && to_string(x) == to_string(y))
      return x;
    else
      return nil;
  }

  if (f == new_sym("<-")) {
    cell* var = car(args);
    if (!is_sym(var)) {
      RAISE << "can't assign to non-sym " << var << '\n';
      return nil;
    }
    cell* val = eval(car(cdr(args)));
    new_binding(var, val);
    return val;
  }

  // lists
  if (f == new_sym("cons")) {
    return new_cons(eval(car(args)), eval(car(cdr(args))));
  }
  if (f == new_sym("car")) {
    cell* arg = eval(car(args));
    return car(arg);
  }
  if (f == new_sym("cdr")) {
    cell* arg = eval(car(args));
    return cdr(arg);
  }

  // numbers
  if (f == new_sym("+")) {
    cell* x = eval(car(args));
    cell* y = eval(car(cdr(args)));
    return new_num(to_int(x) + to_int(y));
  }
  if (f == new_sym("-")) {
    cell* x = eval(car(args));
    cell* y = eval(car(cdr(args)));
    return new_num(to_int(x) - to_int(y));
  }
  if (f == new_sym("*")) {
    cell* x = eval(car(args));
    cell* y = eval(car(cdr(args)));
    return new_num(to_int(x) * to_int(y));
  }
  if (f == new_sym("<")) {
    cell* x = eval(car(args));
    cell* y = eval(car(cdr(args)));
    return (to_int(x) < to_int(y)) ? new_num(1) : nil;
  }
  return NULL;
}

// bind params to args in new_scope, taking into account:
//  quoted params (eval'ing args as necessary; args is never quoted, though)
//  destructured params
void eval_bind_all(cell* params, cell* args) {
  if (params == nil)
    ;

  else if (is_sym(params))
    bind_params(params, eval_all(args));

  else if (!is_cons(params))
    ;

  else {
    bind_params(car(params), eval(car(args)));
    eval_bind_all(cdr(params), cdr(args));
  }
}

void bind_params(cell* params, cell* args) {
  if (params == nil)
    ;

  else if (is_sym(params))
    new_binding(params, args);

  else if (!is_cons(params))
    ;

  else if (args != nil && !is_cons(args))
    bind_params(params, nil);

  else {
    bind_params(car(params), car(args));
    bind_params(cdr(params), cdr(args));
  }
}

cell* eval_all(cell* args) {
  if (!is_cons(args))
    return eval(args);
  cell* p_result = new_cell(), *curr = p_result;
  for (; args != nil; args=cdr(args), curr=cdr(curr))
    add_cons(curr, eval(car(args)));
  return cdr(p_result);
}

unordered_map<cell*, cell*> Bindings;

cell* lookup(string s) {
  return lookup(new_sym(s));
}

cell* lookup(cell* sym) {
  if (!Bindings[sym]) {
    RAISE << "No binding for " << to_string(sym) << '\n';
    return nil;
  }
  return Bindings[sym];
}

void new_binding(string sym, cell* val) {
  new_binding(new_sym(sym), val);
}

void new_binding(cell* sym, cell* val) {
  trace("bind") << sym << ": " << val;
  Bindings[sym] = val;
}

void teardown_bindings() {
  Bindings.clear();
}

bool is_quoted(cell* cell) {
  return is_cons(cell) && car(cell) == new_sym("'");
}

cell* strip_quote(cell* cell) {
  return is_quoted(cell) ? cdr(cell) : cell;
}

bool is_keyword_sym(cell* x) {
  if (!is_sym(x)) return false;
  string name = to_string(x);
  if (name == ":") return false;
  return name[0] == ':';
}

// fn = (sig ... body)
bool is_fn(cell* x) {
  return is_cons(x) && car(x) == new_sym("fn");
}

cell* sig(cell* fn) {
  return car(cdr(fn));
}

cell* body(cell* fn) {
  return cdr(cdr(fn));
}

cell* quote(cell* x) {
  return new_cons(new_sym("'"), x);
}

cell* quote_all(cell* x) {
  cell* result = new_cell(), *curr = result;
  for (cell* iter = x; iter != nil; iter=cdr(iter), curr=cdr(curr))
    add_cons(curr, quote(car(iter)));
  return cdr(result);
}

void add_cons(cell* p, cell* x) {
  set_cdr(p, new_cons(x));
}



cell* next_cell(istream& in) {
  return build_cell(next_ast_node(in));
}

cell* build_cell(ast_node n) {
  new_trace_frame("cell");
  if (n == "") return nil;  // void

  if (is_nil(n)) {
    trace("cell") << "nil";
    return nil;
  }

  if (is_list(n) && n.elems.front() == ")") {
    if (n.elems.size() > 1) RAISE << "Syntax error: ) not at end of expr\n" << die();
    trace("cell") << "nil";
    return nil;
  }

  if (is_atom(n)) {
    errno = 0;
    char* end;
    long v = strtol(n.atom.c_str(), &end, 0);
    if (*end == '\0' && errno == 0) {
      trace("cell") << "num " << v;
      return new_num(v);
    }

    if (n.atom.c_str()[0] == '"') {
      trace("cell") << "string " << n.atom;
      return new_string(n.atom.substr(1, n.atom.length()-2));
    }

    trace("cell") << "sym " << n.atom;
    return new_sym(n.atom);
  }

  list<ast_node>::iterator first = n.elems.begin();
  if (*first == "(") {
    n.elems.pop_front();
    cell* result = build_cell(n);
    trace("cell") << result;
    return result;
  }

  cell* new_form = new_cell();
  set_car(new_form, build_cell(n.elems.front()));

  list<ast_node>::iterator next = first; ++next;
  if (*next == "...") {
    if (next != --n.elems.end())
      set_cdr(new_form, build_cell(*++next));  // dotted pair
    else
      set_cdr(new_form, build_cell(*next));
  }
  else if (is_quote_or_unquote(*first) && n.elems.size() == 2) {
    set_cdr(new_form, build_cell(*next));  // dotted pair
  }
  else {
    n.elems.pop_front();
    if (n.elems.empty())
      RAISE << "Error in parsing " << n << '\n' << die();
    set_cdr(new_form, build_cell(n));
  }

  trace("cell") << new_form;
  return new_form;
}

bool is_nil(const ast_node& n) {
  return n.atom == "nil"
      || (n.elems.size() == 2 && n.elems.front() == "(" && n.elems.back() == ")");
}

:(before "End Types")
// token Decl
struct ast_node {
  token atom;
  list<ast_node> elems;

  explicit ast_node(token t) :atom(t) {}
  explicit ast_node(list<ast_node> l) :elems(l) {}

  bool operator==(const string& x) const {
    return elems.empty() && atom == x;
  }
  bool operator!=(const string& x) const {
    return !(*this == x);
  }
};

:(code)
ast_node next_ast_node(istream& in) {
  list<token> buffered_tokens = next_expr(in);
  return next_ast_node(buffered_tokens);
}

ast_node next_ast_node(list<token>& in) {
  list<ast_node> subform;
  new_trace_frame("parse");
  if (in.empty()) {
    trace("parse") << ast_node(subform);
    return ast_node(subform);
  }

  subform.push_back(ast_node(next_token(in)));
  while (!in.empty() && is_quote_or_unquote(subform.back().atom))
    subform.push_back(ast_node(next_token(in)));

  if (is_open_paren(subform.back())) {
    while (!in.empty() && subform.back() != ")")
      subform.push_back(next_ast_node(in));
    if (!is_close_paren(subform.back())) RAISE << "Unbalanced (\n" << die();
  }

  if (subform.size() == 1) {
    trace("parse") << ast_node(subform.back());
    return ast_node(subform.back());
  }

  trace("parse") << ast_node(subform);
  return ast_node(subform);
}

void test_parse_handles_empty_stream() {
  read_all("");
  CHECK_TRACE_CONTENTS("parse", "");
}

:(scenarios read_all)

:(scenario parse_handles_atoms)
34
"a b c"
+parse: 34
+parse: "a b c"

:(scenario parse_handles_lists)
(34 "a b c")
+parse: (34 "a b c")

:(scenario parse_handles_lists_with_comments)
(a b (c d # abc
))
+parse: (a b (c d))



:(before "End Types")
#define CELLS_PER_HEAP (4*1024/sizeof(cell))  // default linux pagesize
struct heap {
  cell cells[CELLS_PER_HEAP];
  heap *next;
  heap() :next(NULL) {}
};

:(before "End Globals")
heap* First_heap = new heap();
heap* Curr_heap = First_heap;
long Curr_cell = 0;
cell* Free_cells = NULL;

:(code)
void grow_heap() {
  Curr_heap = Curr_heap->next = new heap();
  if (!Curr_heap) RAISE << "Out of memory\n" << die();
  Curr_cell = 0;
}

void reset_heap(heap* h) {
  if (h->next)
    reset_heap(h->next);
  delete h;
  if (h == First_heap) {
    First_heap = new heap();
    Curr_heap = First_heap;
    Curr_cell = 0;
    Free_cells = NULL;
  }
}

cell* new_cell() {
  cell* result = NULL;
  if (Free_cells) {
    result = Free_cells;
    Free_cells = Free_cells->cdr;
    result->init();
    return result;
  }

  if (Curr_cell == CELLS_PER_HEAP)
    grow_heap();

  result = &Curr_heap->cells[Curr_cell];
  ++Curr_cell;
  result->init();
  return result;
}



cell* car(cell* x) {
  if (x->type != CONS) {
    RAISE << "car of non-cons: " << x << '\n';
    return nil;
  }
  return x->car;
}

cell* cdr(cell* x) {
  return x->cdr;
}

void set_car(cell* x, cell* y) {
  if (x == nil) {
    RAISE << "set_car on nil\n";
    return;
  }
  x->car = y;
}

void set_cdr(cell* x, cell* y) {
  if (x == nil) {
    RAISE << "set_cdr on nil\n";
    return;
  }
  x->cdr = y;
}

cell* new_cons(cell* car, cell* cdr) {
  cell* ans = new_cell();
  set_car(ans, car);
  set_cdr(ans, cdr);
  return ans;
}

cell* new_cons(cell* car) {
  return new_cons(car, nil);
}

bool is_cons(cell* x) {
  return x != nil && x->type == CONS;
}

bool is_atom(cell* x) {
  return x == nil || !is_cons(x);
}



//// numbers

:(before "End Globals")
unordered_map<long, cell*> Int_literals;
:(code)
cell* new_num(long x) {
  if (Int_literals[x])
    return Int_literals[x];
  Int_literals[x] = new_cell();
  Int_literals[x]->car = (cell*)x;
  Int_literals[x]->type = INTEGER;
  return Int_literals[x];
}

cell* new_num(int x) {   // just for integer literals
  return new_num((long)x);
}

bool is_num(cell* x) {
  return x->type == INTEGER;
}

long to_int(cell* x) {
  // ignore endianness; cells are never persisted
  if (x->type == INTEGER)
    return (long)x->car;
  RAISE << "not a number: " << x << '\n';
  return 0;
}



//// symbols
:(before "End Globals")
unordered_map<string, cell*> Sym_literals;
:(code)
cell* new_sym(string x) {
  if (Sym_literals[x])
    return Sym_literals[x];
  Sym_literals[x] = new_cell();
  Sym_literals[x]->car = (cell*)new string(x);   // not aligned like cells; can fragment memory
  Sym_literals[x]->type = SYMBOL;
  return Sym_literals[x];
}

bool is_sym(cell* x) {
  return x->type == SYMBOL;
}

cell* new_string(string x) {   // don't intern strings
  cell* result = new_cell();
  result->car = (cell*)new string(x);
  result->type = STRING;
  return result;
}

bool is_string(cell* x) {
  return x->type == STRING;
}

string to_string(cell* x) {
  if (!is_string(x) && !is_sym(x)) {
    RAISE << "can't convert to string: " << x << '\n';
    return "";
  }
  return *(string*)x->car;
}



list<token> next_expr(istream& in) {
  list<token> result;   // emit tokens here

  long explicit_open_parens = 0;
  for(;;) {
    if (in.eof()) break;
    result.push_back(next_token(in));
    if (result.back() == "(") ++explicit_open_parens;
    if (result.back() == ")") --explicit_open_parens;
    if (!is_quote_or_unquote(result.back()) && explicit_open_parens == 0) break;
  }
  if (result.empty()) result.push_back("");
  return result;
}

:(after "token Decl")
typedef string token;
:(before "End Globals")
const string Punctuation_chars = "()#\"";

:(code)
token next_token(istream& in) {
  in >> std::noskipws;
  for (;;) {
    skip_whitespace(in);
    if (in.peek() == '#')
      skip_comment(in);
    else
      break;
  }
  ostringstream out;
  if (in.peek() == '"')
    slurp_string(in, out);
  else if (find(Punctuation_chars, in.peek()))
    slurp_char(in, out);
  else if (in.peek() == '\'')
    slurp_char(in, out);
  else
    slurp_word(in, out);

  trace("tokenize") << out.str();
  return token(out.str());
}

// slurp functions read a token when you're sure to be at it
void slurp_word(istream& in, ostream& out) {
  char c;
  while (in >> c) {
    if (isspace(c) || find(Punctuation_chars, c)) {
      in.putback(c);
      break;
    }
    out << c;
  }
}

void slurp_string(istream& in, ostream& out) {
  slurp_char(in, out);   // initial quote
  char c;
  while (in >> c) {
    out << c;
    if (c == '\\')
      slurp_char(in, out);   // escape; blindly read next
    else if (c == '"')
      break;
  }
}

void slurp_char(istream& in, ostream& out) {
  out << (char)in.get();
}

void skip_whitespace(istream& in) {
  while (isspace(in.peek()))
    in.get();
}

void skip_comment(istream& in) {
  char c;
  while (in >> c) {
    if (c == '\n') {
      in.putback(c);
      break;
    }
  }
}

list<cell*> read_all(string s) {
  stringstream in(s);
  return read_all(in);
}

bool find(string s, char c) {
  return s.find(c) != NOT_FOUND;
}

:(scenarios read_all)

:(scenario tokenize_breaks_at_whitespace)
34 abc 3.4
+tokenize: 34
+tokenize: abc
+tokenize: 3.4

:(scenario tokenize_handles_string_literals)
34 "abc"
+tokenize: 34
+tokenize: "abc"

:(scenario tokenize_handles_multiple_lines)
34
"abc"
+tokenize: 34
+tokenize: "abc"

:(scenario tokenize_handles_string_with_space)
34
"abc def"
+tokenize: 34
+tokenize: "abc def"

:(scenario tokenize_handles_string_with_escape)
34
"abc \"def"
+tokenize: 34
+tokenize: "abc \"def"

:(scenario tokenize_skips_comment)
34 #abc
+tokenize: 34
-tokenize: #abc

:(scenario tokenize_skips_multiple_comment_lines)
34 #abc
# def gh
35
+tokenize: 34
+tokenize: 35
-tokenize: #abc
-tokenize: # def gh

:(scenario tokenize_breaks_at_punctuation)
() a(b c)"def"
+tokenize: (
+tokenize: )
+tokenize: a
+tokenize: (
+tokenize: b
+tokenize: c
+tokenize: )
+tokenize: "def"

:(code)
bool is_paren(const token& t) {
  return t == "(" || t == ")";
}

bool is_quote_or_unquote(const token& t) {
  return t == "'";
}

void setup_cells() {
  setup_nil();
  Int_literals.clear();
  Sym_literals.clear();
  reset_heap(First_heap);
}

token next_token(list<token>& in) {
  token result = in.front(); in.pop_front();
  return result;
}

bool is_list(const ast_node& n) {
  return !n.elems.empty();
}

bool is_atom(const ast_node& n) {
  return n.elems.empty();
}

bool is_quote_or_unquote(const ast_node& n) {
  return is_atom(n) && is_quote_or_unquote(n.atom);
}

bool is_open_paren(const ast_node& n) {
  return n == "(";
}
bool is_close_paren(const ast_node& n) {
  return n == ")";
}

ostream& operator<<(ostream& os, ast_node x) {
  if (x.elems.empty()) return os << x.atom;
  bool skip_next_space = true;
  for (list<ast_node>::iterator p = x.elems.begin(); p != x.elems.end(); ++p) {
    if (!is_close_paren(*p) && !skip_next_space)
      os << " ";
    os << *p;
    skip_next_space = (is_open_paren(*p) || is_quote_or_unquote(*p));
  }
  return os;
}

// we might be at eof and just not know it if we haven't looked around yet
bool eof(istream& in) {
  in.peek();
  return in.eof();
}

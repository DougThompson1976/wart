;; http://vagueinnovation.com/pragmatic_gp/?p=375

(def pile-exec(pgm x ? stack nil)
  (if (no pgm)
    stack
    (acase car.pgm
      'floatp   (pile-exec cdr.pgm x (cons it stack))
      '(+ - / *)  (pile-exec cdr.pgm x (pile-apply it stack))
      'x  (pile-exec cdr.pgm x (cons x stack))
      (pile-exec cdr.pgm x stack))))

(def pile-apply(op stack)
  (let (a b . rest) stack
    (if (or no.a no.b)
      stack
      (cons
        (if (and (zerop a)
                 (iso op '/))
          0
          (call op b a))
        rest))))



(= pile-tokens* '(+ - * / x k))

(def generate-list(of from)
  (let n len.from
    (n-of of (call from rand.n))))
  ; faster than (n-of of randpos.from)

(def drop-in-floats(x)
  (if (iso x 'k)
    (fprec 3 (- (rand 40.0) 20))
    x))

(def generate-pile-program(n ? tokens pile-tokens*)
  (map 'drop-in-floats
       (generate-list :of n :from tokens)))



(def pile-eval(pgm x)
  (aif (pile-exec pgm x)
    car.it
    1000000000.0))

(def pile-score(pgm input-outputs)
  (sumlist 'sq (map [- (pile-eval pgm :x _.0) _.1]
                    input-outputs)))

(= x-plus-6
   ; https://gist.github.com/710987#file_x_plus_6.csv
   '((-453.064 -447.064)
     (-445.975 -439.975)
     (-259.416 -253.416)
     (-154.381 -148.381)
     (195.842 201.842)
     (216.271 222.271)
     (299.091 305.091)
     (335.118 341.118)
     (431.005 437.005)))

; graph at http://vagueinnovation.com/pragmatic_gp/?p=522
; (map [call log^pile-score _ x-plus-6] (n-of 1000 (generate-pile-program 20)))



(def mutate(s prob ? from pile-tokens*)
  (if s
    (cons (if (< (rand 1.0) prob)
            (drop-in-floats randpos.from)
            car.s)
          (mutate cdr.s prob from))))

(def crossover(p1 p2)
  (with (x1 (rand (1+ len.p1))
         x2 (rand (1+ len.p2)))
    (list (join (cut p1 0 x1) (cut p2 x2))
          (join (cut p1 x1) (cut p2 0 x2)))))



; http://vagueinnovation.com/pragmatic_gp/?p=548

(= gpscores ())
(def score(x)
  (ret score (pile-score x x-plus-6)
    (push (list score x) gpscores)))

(def gp(initial-size length iters)
  (let population (n-of initial-size generate-pile-program.length)
    (= x 0)
    (map 'score population)
    (repeat iters
      (prn ++.x)
;?       (each p population
;?         (prn " " p))
      (withs (p1 randpos.population
              p2 randpos.population
              (a b) (crossover p1 p2))
;?         (prn "parents: " (list p1 score.p1 p2 score.p2))
        (zap [mutate _ :prob 0.01] a)
        (zap [mutate _ :prob 0.01] b)
;?         (prn "children: " (list a score.a b score.b))
        (zap [join (rem (list p1 p2) _)
                   (cut (sort :by 'score (list p1 p2 a b))
                        2)]
             population)))))

;? (gp 100 30 10000)

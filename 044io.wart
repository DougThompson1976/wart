(def serialize(x)
  x)
(def serialize(x) :case (isa x 'cons)
  (map 'serialize x))

; just to avoid errors while debugging
(def serialize(x) :case functionp.x
  'function)

(def unserialize(x)
  x)
(def unserialize(x) :case (isa x 'cons)
  (map 'unserialize x))



(def wart-read(? stream stdin*)
  (unserialize read.stream))
(defover read wart-read)

(redef wart-write(x ? stream stdout*)
  (write serialize.x :stream stream))
(defover write wart-write)

(def ero args
  (w/stdout stderr*
    (apply 'writeln args)))



(def serialize(x) :case (isa x 'hash-table)
  ; beware: all generics will see this as a hash, but only unserialize can handle it
  (annotate 'hash-table
            (map 'serialize (coerce x 'cons))))

(def unserialize(x) :case (isa x 'hash-table)
  (ret ans (table)
    (each (k v) (as hash-table rep.x)
      (= (call ans unserialize.k) unserialize.v))))



(def peek(stream)
  (peek-char nil stream nil))

(def wart-read-line(stream)
  (read-line stream nil))
(defover read-line wart-read-line)

(def slurp(stream)
  (intersperse #\newline
               (drain read-line.stream)))

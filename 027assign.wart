; freeze sym assignment against future refinements
let $= =
  mac =(lhs rhs) :case (sym? lhs)
    `(,$= ,lhs ,rhs)



; basic type-based dispatch
mac =(lhs rhs) :case !sym?.lhs
  ; multiple-eval in case car.lhs needs assigning to
  `((table_get (table_get coercions* 'function=) (type ,car.lhs)) ,lhs ,rhs)

; support new types in =
; body must return a form that will be macro-eval'd
mac defset(type params . body)
  `(defcoerce ,type function=
     (mfn ',params
       ,@body))



; keyword-based dispatch
                          ; hack: can't bind non-sym non-conses
mac =(lhs rhs) :case (and !sym?.lhs (table_get coercions* car.lhs))
  `((table_get coercions* ',car.lhs) ,@cdr.lhs ,rhs)

; support new keywords in =
mac def=(op params . body)
  `(table_set coercions* ',op (fn ,params ,@body))



; serial assignment
; this should be after clauses inspecting args
let $= =
  mac = args
    if args
      `(ret $ans ,cadr.args
         (,$= ,car.args $ans)
         (= ,@cddr.args))

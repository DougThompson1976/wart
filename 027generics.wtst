(test "len works by default"
  :valueof (len nil)
  :should be 0)

(test "len works by default - 2"
  :valueof (len '(1 2 3))
  :should be 3)

(test "len works on hash tables"
  :valueof (len (obj 1 2 3 4))
  :should be 2)



(test "iso works like equal by default"
  :valueof (iso nil nil)
  :should be t)

(wt-eval '(defmethod iso(x y) footype
            (and (position 3 rep.x)
                 (position 3 rep.y))))

(test-wart "defmethod for iso takes"
  :valueof (annotate 'footype '(1 2 3))
  :should be (annotate 'footype '(3 4 5)))

(test-wart "iso works by coercing empty tables"
  :valueof (table)
  :should be (table))

(test-wart "iso works on tables using defmethod"
  :valueof (obj 1 2 3 4)
  :should be (obj 3 4 1 2))



(test-wart "all works"
  :valueof (all 'idfn '(1 2 3))
  :should be t)

(test-wart "all works - 2"
  :valueof (all 'idfn '(1 nil 3))
  :should be nil)

(test-wart "all works on strings"
  :valueof (all #\a "aaa")
  :should be t)

(test-wart "keep works"
  :valueof (keep 'oddp '(1 2 3))
  :should be '(1 3))

(test-wart "keep works on strings"
  :valueof (keep [is _ #\a] "abc")
  :should be "a")

(test-wart "rem works"
  :valueof (rem 'oddp '(1 2 3))
  :should be '(2))

(test-wart "rem works on strings"
  :valueof (rem #\a "abracadabra")
  :should be "brcdbr")

(test-wart "cut works"
  :valueof (cut '(1 2 3 4) 2)
  :should be '(3 4))

(test-wart "cut works on strings"
  :valueof (cut "abc" 1)
  :should be "bc")

(test-wart "join still works"
  :valueof (join '(1) '(2 3))
  :should be '(1 2 3))

(test-wart "join works on strings"
  :valueof (join "abc" "def")
  :should be "abcdef")



; integration test: obj + set + iso
(test-wart "setting inside compound structures works"
  :valueof (ret aa (obj a '(1 2) b 3)
             (= aa!a.1 34))
  :should be (obj a '(1 34) b 3))

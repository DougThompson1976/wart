def inline(calls env)
  collect:each call calls
    (if
      (or !call !cons?.call)
        yield call
      (compiled-fn? car.call)
        yield call
      (fn? car.call)
        let f (rep car.call)
          each x (inline (apply-bindings f!body (cons (as table (gen-bindings f!sig cdr.call)) f!env))
                         (if f!env (cons f!env env) env))
            yield x
      (~fn?:lookup-binding car.call env)
        yield call
      (compiled-fn?:lookup-binding car.call env)
        yield call
      :else
        let f (rep:lookup-binding car.call env)
          each x (inline (apply-bindings f!body (cons (as table (gen-bindings f!sig cdr.call)) f!env))
                         (if f!env (cons f!env env) env))
            yield x)



;; internals

; XXX: multiple-eval
def gen-bindings(params args acc)
  (if
    !params ; base case
      acc
    ~cons?.params ; rest param
      (cons (list params (cons 'list args))
            acc)
    (and (iso car.params quote)
         (~cons? cdr.params)) ; quoted rest param
      (cons (list cdr.params (cons 'list args))
            acc)
    (~cons? car.params)
      (cons (list car.params car.args)
            (gen-bindings cdr.params cdr.args acc))
    :else ; destructured param
      (gen-bindings car.params car.args
               (gen-bindings cdr.params cdr.args acc)))

def apply-bindings(expr bindings)
  if !cons?.expr
    (or (lookup-binding expr bindings) expr)
    (cons (apply-bindings car.expr bindings)
          (apply-bindings cdr.expr bindings))

def lookup-binding(sym bindings)
  (if
    !bindings
      nil
    !cons?.bindings
      bindings.sym
    :else
      (or (lookup-binding sym car.bindings)
          (lookup-binding sym cdr.bindings)))

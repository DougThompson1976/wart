def to-with-expr(call bindings done)
  (iflet f (and (~pos car.call done) ; skip recursive calls
                (lookup-or-eval car.call bindings))
    `(with ,(scope->with-bindings env.f)
       ,(if
          (quote?:car sig.f)
            `(with (,cdr:sig.f ',cdr.call)
               ,@(collect:each expr body.f
                   (if (iso car.expr 'eval)
                     (yield `(,expr.0 ,expr.1)) ; strip caller-scope
                     (yield:to-with-expr expr
                                         (maybe chain-scope env.f :to bindings)
                                         (cons car.call done)))))
          (contains-quote? sig.f)
            `((fn ,sig.f ,@body.f) ,@cdr.call)
          :else
            `(with (,sig.f ,(cons 'list cdr.call))
               ,@(collect:each expr body.f
                   (yield:to-with-expr expr
                                       (maybe chain-scope env.f :to bindings)
                                       (cons car.call done))))))
    call)

def inline-macro-eval(expr bindings)
  if (~match '(with . _) expr)
    expr
    `(with ,expr.1 ,@(collect:each x (expr 2 nil)
                       (yield:or (if (and (match '(eval . _) x)
                                          (backquote?:car x.1))
                                   (check (apply-comma-bindings cdr:x.1 ; strip backquote
                                              (maybe chain-scope with-bindings->scope:expr.1 :to bindings))
                                          ~has-comma-bindings))
                                 x)))



;; Internals

def lookup-or-eval(f bindings)
  (if
    sym?.f
      if bindings
        (or bindings.f
            (lookup-or-eval f cdr.bindings))
    (match '(fn . _) f)
      eval.f)

def contains-quote?(expr)
  if ~cons?.expr
    quote?.expr
    (or (contains-quote? car.expr)
        (contains-quote? cdr.expr))

def scope->with-bindings(s)
  (join @(rem (fn(x) (match '(caller-scope . _) x))
              (as list s)))

def with-bindings->scope(bindings)
  ret ans (eval `(with ,bindings curr-scope.) caller-scope)
    wipe ans!caller-scope
    wipe cdr.ans

def curr-scope()
  caller-scope

; unquoted exprs shouldn't have side effects
def apply-comma-bindings(expr bindings)
  (if
    !cons?.expr
      expr
    unquote?:car.expr
      (or (try-eval cdr.expr bindings)
          expr) ; failure = expr still has commas
    (match (cons unquote-splice '_) car.expr)
      (iflet splice (try-eval cdr:car.expr bindings)
        (join splice
              (apply-comma-bindings cdr.expr bindings))
        expr)
    :else
      (cons (apply-comma-bindings car.expr bindings)
            (apply-comma-bindings cdr.expr bindings)))

def has-comma-bindings(expr)
  (if
    !cons?.expr
      nil
    unquote?:car.expr
      expr
    (match (cons unquote-splice '_) car.expr)
      car.expr
    backquote?:car.expr
      nil
    :else
      (or has-comma-bindings:car.expr
          has-comma-bindings:cdr.expr))

def chain-scope(a b)
  ret ans copy.a
    let curr ans
      while cdr.curr
        zap cdr curr
      = cdr.curr b

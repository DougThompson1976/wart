def to-with-expr(call bindings done)
  (iflet f (and (~pos car.call done) ; skip recursive calls
                (lookup-or-eval car.call bindings))
    `(with ,(scope->with-bindings env.f)
       ,(if
          (quote? car:sig.f)
            `(with (,cdr:sig.f ',cdr.call)
               ,@(collect:each expr body.f
                   (if (iso car.expr 'eval)
                     (yield `(,expr.0 ,expr.1)) ; strip caller-scope
                     (yield:to-with-expr expr
                                         (maybe cons env.f :to bindings)
                                         (cons car.call done)))))
          (contains-quote? sig.f)
            `((fn ,sig.f ,@body.f) ,@cdr.call)
          :else
            `(with (,sig.f ,(cons 'list cdr.call))
               ,@(collect:each expr body.f
                   (yield:to-with-expr expr
                                       (maybe cons env.f :to bindings)
                                       (cons car.call done))))))
    call)



;; Internals

def lookup-or-eval(f bindings)
  (if
    sym?.f
      (if cons?.bindings
        (or (car.bindings f)
            (lookup-or-eval f cdr.bindings))
        bindings.f)
    (match '(fn . _) f)
      eval.f)

def contains-quote?(expr)
  if ~cons?.expr
    quote?.expr
    (or (contains-quote? car.expr)
        (contains-quote? cdr.expr))

def scope->with-bindings(s)
  (join @(rem (fn(x) (match '(caller-scope . _) x))
              (as list s)))

def with-bindings->scope(bindings)
  ret ans (eval `(with ,bindings curr-scope.) caller-scope)
    wipe ans!caller-scope
    wipe cdr.ans

def curr-scope()
  caller-scope

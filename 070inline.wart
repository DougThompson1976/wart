; inline all function bodies into with-exprs:
;   (def foo(a b) (prn a) (+ a b))
;   (foo x y)
;   => (withs ((a b) (list x y))
;        (prn a)
;        (+ a b))
;
; Parts of with-exprs:
;   (withs bindings body)
; Parts of bindings: var exp
def to-with-expr(call bindings done)
  (iflet f (and (~pos car.call done) ; skip recursive calls
                (lookup-or-eval car.call bindings))
    `(withs ,(scope->with-bindings env.f)
       ,(if
          (quote?:car sig.f)
            `(withs (,cdr:sig.f ',cdr.call)
               ,@(collect:each expr body.f
                   (if (iso car.expr 'eval)
                     (yield `(,expr.0 ,expr.1)) ; strip caller-scope
                     (yield:to-with-expr expr
                                         (maybe chain-scope env.f :to bindings)
                                         (cons car.call done)))))
          (contains-quote? sig.f)
            `((fn ,sig.f ,@body.f) ,@cdr.call)
          :else
            `(withs (,sig.f ,(cons 'list cdr.call))
               ,@(collect:each expr body.f
                   (yield:to-with-expr expr
                                       (maybe chain-scope env.f :to bindings)
                                       (cons car.call done))))))
    call)

def inline-macro-eval(expr bindings)
  if (~match '(withs . _) expr)
    expr
    `(withs ,expr.1 ,@(collect:each x (expr 2 nil)
                        (yield:or (if (and (match '(eval . _) x)
                                           (backquote?:car x.1))
                                    (check (apply-comma-bindings cdr:x.1 ; strip backquote
                                               (maybe chain-scope with-bindings->scope:expr.1 :to bindings))
                                           ~has-comma-bindings))
                                  x)))

def mangle-binding(expr var new)
  (if
    (iso var expr)
      new
    ~cons?.expr
      expr
    (~match '(withs . _) expr)
      (cons (mangle-binding car.expr var new)
            (mangle-binding cdr.expr var new))
    :else ; (withs . _)
      `(withs ,(mangle-binding-in-bindings expr.1 var new)
         ,@(mangle-binding-in-body expr var new)))

def mangle-binding-in-bindings(bindings var new)
  if bindings
    (list bindings.0
          (mangle-binding bindings.1 var new)
          @(mangle-binding-in-bindings cddr.bindings var new))

def mangle-binding-in-body(with-expr var new)
  if (~match '(withs . _) with-expr)
    'fail
    if (creates-binding with-expr.1 var)
      cddr.with-expr
      (mangle-binding cddr.with-expr var new)

def creates-binding(bindings var)
  if bindings
    (or (iso bindings var)
        (and cons?.bindings
             (pos var flatten:bindings.1))
        (creates-binding cddr.bindings var))

; Assumes there are no conflicting bindings
def coalesce-bindings(expr)
  let (bindings body) (collect-bindings-body expr)
    `(withs ,bindings ,@body)



;; Internals

def lookup-or-eval(f bindings)
  (if
    sym?.f
      if bindings
        (or bindings.f
            (lookup-or-eval f cdr.bindings))
    (match '(fn . _) f)
      eval.f)

def contains-quote?(expr)
  if ~cons?.expr
    quote?.expr
    (or (contains-quote? car.expr)
        (contains-quote? cdr.expr))

def scope->with-bindings(s)
  (join @(rem (fn(x) (match '(caller-scope . _) x))
              (as list s)))

def with-bindings->scope(bindings)
  w/table ans
    for curr (eval `(withs ,bindings curr-scope.) caller-scope)
             cdr.curr ; HACK: ignore the scope with the 'bindings' binding
             (zap cdr curr)
      each k keys.curr
        if (~iso 'caller-scope k)
          or= ans.k curr.k

def curr-scope()
  caller-scope

; unquoted exprs shouldn't have side effects
def apply-comma-bindings(expr bindings)
  (if
    !cons?.expr
      expr
    unquote?:car.expr
      (or (try-eval cdr.expr bindings)
          expr) ; failure = expr still has commas
    (match (cons unquote-splice '_) car.expr)
      (iflet splice (try-eval cdr:car.expr bindings)
        (join splice
              (apply-comma-bindings cdr.expr bindings))
        expr)
    :else
      (cons (apply-comma-bindings car.expr bindings)
            (apply-comma-bindings cdr.expr bindings)))

def has-comma-bindings(expr)
  (if
    !cons?.expr
      nil
    unquote?:car.expr
      expr
    (match (cons unquote-splice '_) car.expr)
      car.expr
    backquote?:car.expr
      nil
    :else
      (or has-comma-bindings:car.expr
          has-comma-bindings:cdr.expr))

def chain-scope(a b)
  ret ans copy.a
    let curr ans
      while cdr.curr
        zap cdr curr
      = cdr.curr b

def collect-bindings-body(expr)
  (if
    (match '(withs . _) expr)
      let (bindings body) (collect-bindings-body (cons 'do (expr 2 nil)))
        (list (join expr.1 bindings) body)
    (match '(do . _) expr)
      let (bindings body) '(nil nil)
        each form cdr.expr
          let (bn bd) collect-bindings-body.form
            = bindings (join bindings bn)
            = body (join body bd)
        (list bindings body)
    :else
      (list nil list.expr))

def new-vars(conflicts)
  collect:each var conflicts
    yield (new-var var conflicts)

def new-var(var conflicts)
  if (~pos var conflicts)
    var
    (uniq sym-root.var)

; bindings are alternating var-exp pairs
; conflicts is a table from syms to their new names
; search for a conflict in just vars, and replace throughout later pairs
def rename-vars-in-bindings(conflicts bindings)
  (if
    ~cons?.bindings
      nil
    (conflicts car.bindings)
      let new (conflicts car.bindings)
        (list new cadr.bindings
              @(rename-vars-in-bindings conflicts
                                        (replace car.bindings new cddr.bindings)))
    ~cons?:car.bindings
      (list car.bindings cadr.bindings ; no rename in exp
            @(rename-vars-in-bindings conflicts cddr.bindings))
    :else
      'todo)

def replace(old new expr)
  (if
    (iso old expr)
      new
    ~cons?.expr
      expr
    quote?:car.expr
      expr
    ; TODO: what about backquoted exprs?
    :else
      (cons (replace old new car.expr)
            (replace old new cdr.expr)))

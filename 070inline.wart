def inline(calls bindings)
  collect:each call calls
    if (or !call !cons?.call)
      yield call
      let f (or (if
                  (sym? car.call)
                    (lookup-binding car.call bindings)
                  (and cons?:car.call (iso 'fn car:car.call))
                    (eval car.call))
                car.call)
        (if
          (or ~callable?.f compiled-fn?.f)
            yield call
          fn?.f
            each x (inline (apply-bindings body.f (cons (as table (gen-bindings sig.f cdr.call)) env.f))
                           (if env.f (cons env.f bindings) bindings))
              yield x
          inlinable-mac?.f
            each x (inline (apply-comma-bindings body.f (cons (as table (gen-bindings sig.f cdr.call)) env.f))
                           (if env.f (cons env.f bindings) bindings))
              yield x
          :else
            yield call)



;; internals

def gen-bindings(params args acc)
  if (and cons?.params quote?:car.params)
    (zap cdr params) ; inline never distinguishes quoted params
  (if
    !params ; base case
      acc
    ~cons?.params ; rest param
      (cons (list params (cons 'list args))
            acc)
    (~cons? car.params)
      (cons (list car.params car.args)
            (gen-bindings cdr.params cdr.args acc))
    :else ; destructured param
      (gen-bindings car.params car.args
               (gen-bindings cdr.params cdr.args acc)))

def apply-bindings(expr bindings)
  if !cons?.expr
    (or (lookup-binding expr bindings) expr)
    (cons (apply-bindings car.expr bindings)
          (apply-bindings cdr.expr bindings))

def lookup-binding(sym bindings)
  (if
    !bindings
      nil
    !cons?.bindings
      bindings.sym
    :else
      (or (lookup-binding sym car.bindings)
          (lookup-binding sym cdr.bindings)))

def inlinable-mac?(f)
  and mac?.f
      (~cdr body.f) ; no support for multiple exprs for now
      (and cons?:body.f cons?:car:body.f (iso backquote car:car:body.f)) ; begins with quasiquote
      ; can't unquote lexical bindings for now
      (contains? (map str unquoted-syms:body.f)
                 (map str flatten:sig.f))

; sub and l sorted lists of syms
def contains?(sub l)
  (if
    (or !l !sub)
      1
    (< car.sub car.l)
      nil
    (iso car.sub car.l)
      (contains? cdr.sub cdr.l)
    :else
      (contains? sub cdr.l))

def unquoted-syms(expr)
  if cons?.expr
    if (or (comma? car.expr) (comma-splice? car.expr))
      (list cdr.expr)
      (join (unquoted-syms car.expr)
            (unquoted-syms cdr.expr))

def apply-comma-bindings(expr bindings)
  (if
    !cons?.expr
      expr
    backquote?:car.expr
      (apply-comma-bindings cdr.expr bindings)
    comma?:car.expr
      (or (lookup-binding cdr.expr bindings)
          (die "macro with free var: " cdr.expr))
    (and cons?:car.expr comma-splice?:car:car.expr)
      let l (lookup-binding cdr:car.expr bindings)
        if !l (die "macro with free var: " cdr:car.expr)
        if (~iso 'list car.l) (die car:car.expr " must be a list for now")
        (join cdr.l
              (apply-comma-bindings cdr.expr bindings))
    :else
      (cons (apply-comma-bindings car.expr bindings)
            (apply-comma-bindings cdr.expr bindings)))

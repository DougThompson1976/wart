; inline all function bodies into with-exprs:
;   (def foo(a b) (prn a) (+ a b))
;   (foo x y)
;   => (withs ((a b) (list x y))
;        (prn a)
;        (+ a b))
;
; Parts of with-exprs:
;   (withs bindings body)
; Parts of bindings: var exp
;
; Macros are specially tagged with 'mac-withs.
def to-with-expr(call bindings done)
  (iflet f (and (~pos car.call done) ; skip recursive calls
                (lookup-or-eval car.call bindings))
    `(withs ,(scope->with-bindings env.f)
       ,(if
          (quote?:car sig.f)
            `(mac-withs (,cdr:sig.f ',cdr.call)
               ,@(collect:each expr body.f
                   (if (iso car.expr 'eval)
                     (yield `(,expr.0 ,expr.1)) ; strip caller-scope
                     (yield:to-with-expr expr
                                         (maybe chain-scope env.f :to bindings)
                                         (cons car.call done)))))
          (contains-quote? sig.f)
            `((fn ,sig.f ,@body.f) ,@cdr.call)
          :else
            `(withs (,sig.f ,(cons 'list cdr.call))
               ,@(collect:each expr body.f
                   (yield:to-with-expr expr
                                       (maybe chain-scope env.f :to bindings)
                                       (cons car.call done))))))
    call)

; assumes macros are converted to the very specific structure
;   (mac-withs (_ '_) ... (eval _ caller-scope))
def inline-macro-eval(expr bindings)
  (if
    (is-match '(withs . _) expr)
      (let new-bindings (maybe chain-scope with-bindings->scope:expr.1 :to bindings)
        `(withs ,expr.1 ,@(map (fn(_) (inline-macro-eval _ new-bindings))
                               withs-body.expr)))
    (normal-macro? expr)
      `(withs ,(macro-unquote-bindings expr.1)
              ,@(collect:each x withs-body.expr
                  (yield:or (if (and (is-match '(eval . _) x)
                                     (backquote?:car x.1))
                              (check (apply-comma-bindings cdr:x.1 ; strip backquote
                                         (maybe chain-scope with-bindings->scope:expr.1 :to bindings))
                                     ~has-comma-bindings))
                            x)))
    :else
      expr)

; mangle-names '(withs (a 1) (withs (a 2) (+ a 3))) '()
  ; => rename-vars '(withs (a 1) (withs (a 2) (+ a 3))) {} '(a)
  ; => rename-vars-in-body '((withs (a 2) (+ a 3))) {} '(a)
  ; => mangle-all '((withs (a 2) (+ a 3))) '(a)
  ; => mangle-names '(withs (a 2) (+ a 3)) '(a)
  ; => rename-vars '(withs (a 2) (+ a 3)) {a: a2} '(a a2)
    ; => rename-vars-in-body "
      ; => mangle-all '((+ a 3)) '(a a2)
        ; => mangle-names '(+ a 3) '(a a2)
        ; <= '(+ a 3)
      ; => replace-all '(+ a 3) {a: a2}
      ; <= '(+ a2 3)
    ; <= '(+ a2 3)
  ; <= '(withs (a2 2) (+ a2 3))
; <= '(withs (a 1) (withs (a2 2) (+ a2 3)))
def mangle-names(with-expr vars)
  if (~is-match '(withs . _) with-expr)
    with-expr
    withs (new-bindings   (flatten:map car pair:with-expr.1)
           conflicting-vars   (intersection vars new-bindings)
           conflicts  new-vars.conflicting-vars)
      (rename-vars with-expr conflicts (join vars new-bindings))



;; Internals

def normal-macro?(expr)
  and (is-match '(mac-withs . _) expr)
      (is-match '(eval _) last:withs-body.expr)

def macro-unquote-bindings(bindings)
  if (and pair?.bindings
          quote?:car:bindings.1)
    `(,bindings.0 ,(cons 'list cdr:bindings.1))

; unquoted exprs shouldn't have side effects
def apply-comma-bindings(expr bindings)
  (if
    !cons?.expr
      expr
    unquote?:car.expr
      (or (try-eval cdr.expr bindings)
          expr) ; failure = expr still has commas
    (is-match (cons unquote-splice '_) car.expr)
      (iflet splice (try-eval cdr:car.expr bindings)
        (join splice
              (apply-comma-bindings cdr.expr bindings))
        expr)
    :else
      (cons (apply-comma-bindings car.expr bindings)
            (apply-comma-bindings cdr.expr bindings)))

def has-comma-bindings(expr)
  (if
    !cons?.expr
      nil
    unquote?:car.expr
      expr
    (is-match (cons unquote-splice '_) car.expr)
      car.expr
    backquote?:car.expr
      nil
    :else
      (or has-comma-bindings:car.expr
          has-comma-bindings:cdr.expr))

def rename-vars(expr conflicts vars)
  if (~is-match '(withs . _) expr)
    (replace-all conflicts expr)
    `(withs ,(rename-vars-in-bindings conflicts expr.1)
       ,@(rename-vars-in-body withs-body.expr conflicts vars))

; bindings are alternating var-exp pairs
; conflicts is a table from syms to their new names
; search for a conflict in just vars, and replace throughout later pairs
def rename-vars-in-bindings(conflicts bindings)
  (if
    ~cons?.bindings
      nil
    (conflicts car.bindings)
      let new (conflicts car.bindings)
        (list new cadr.bindings
              @(rename-vars-in-bindings conflicts
                                        (replace car.bindings new cddr.bindings)))
    ~cons?:car.bindings
      (list car.bindings cadr.bindings ; no rename in exp
            @(rename-vars-in-bindings conflicts cddr.bindings))
    :else
      'todo)

def rename-vars-in-body(body conflicts vars)
  (replace-all conflicts (mangle-all body vars))

def mangle-all(body vars)
  collect:each form body
    yield (mangle-names form vars)

def lookup-or-eval(f bindings)
  (if
    sym?.f
      if bindings
        (or bindings.f
            (lookup-or-eval f cdr.bindings))
    (is-match '(fn . _) f)
      eval.f)

def contains-quote?(expr)
  if ~cons?.expr
    quote?.expr
    (or (contains-quote? car.expr)
        (contains-quote? cdr.expr))

def scope->with-bindings(s)
  (join @(rem (fn(x) (is-match '(caller-scope . _) x))
              (as list s)))

def with-bindings->scope(bindings)
  w/table ans
    for curr (eval `(withs ,bindings curr-scope.) caller-scope)
             cdr.curr ; HACK: ignore the scope with the 'bindings' binding
             (zap cdr curr)
      each k keys.curr
        if (~iso 'caller-scope k)
          or= ans.k curr.k

def curr-scope()
  caller-scope

def chain-scope(a b)
  ret ans copy.a
    let curr ans
      while cdr.curr
        zap cdr curr
      = cdr.curr b

def replace(old new expr)
  (if
    (iso old expr)
      new
    ~cons?.expr
      expr
    quote?:car.expr
      expr
    ; TODO: what about backquoted exprs?
    :else
      (cons (replace old new car.expr)
            (replace old new cdr.expr)))

def replace-all(conflicts expr)
  each (k v) conflicts
    = expr (replace k v expr)
  expr

def new-vars(conflicts)
  w/table h
    each var conflicts
      = h.var (uniq sym-root.var)

def withs-body(with-expr)
  (with-expr 2 nil)

def intersection(a b)
  collect:each x a
    if (pos x b)
      yield x

def to-with-expr(call bindings done)
  (iflet f (and (~pos car.call done) ; skip recursive calls
                (lookup-or-eval car.call bindings))
    `(with ,(scope->with-bindings env.f)
       ,(if
          (quote? car:sig.f)
            `(with (,cdr:sig.f ',cdr.call)
               ,@(collect:each expr body.f
                   (if (iso car.expr 'eval)
                     (yield `(,expr.0 ,expr.1)) ; strip caller-scope
                     (yield:to-with-expr expr
                                         (maybe cons env.f :to bindings)
                                         (cons car.call done)))))
          (contains-quote? sig.f)
            `((fn ,sig.f ,@body.f) ,@cdr.call)
          :else
            `(with (,sig.f ,(cons 'list cdr.call))
               ,@(collect:each expr body.f
                   (yield:to-with-expr expr
                                       (maybe cons env.f :to bindings)
                                       (cons car.call done))))))
    call)

def inline-macro-eval(expr bindings)
  if (~match '(with . _) expr)
    expr
    `(with ,expr.1 ,@(collect:each x (expr 2 nil)
                       (yield:if (~match '(eval . _) x)
                         x
                         (apply-bindings x.1
                              (cons with-bindings->scope:expr.1 bindings)))))



;; Internals

def lookup-or-eval(f bindings)
  (if
    sym?.f
      (if cons?.bindings
        (or (car.bindings f)
            (lookup-or-eval f cdr.bindings))
        bindings.f)
    (match '(fn . _) f)
      eval.f)

def contains-quote?(expr)
  if ~cons?.expr
    quote?.expr
    (or (contains-quote? car.expr)
        (contains-quote? cdr.expr))

def scope->with-bindings(s)
  (join @(rem (fn(x) (match '(caller-scope . _) x))
              (as list s)))

def with-bindings->scope(bindings)
  ret ans (eval `(with ,bindings curr-scope.) caller-scope)
    wipe ans!caller-scope
    wipe cdr.ans

def curr-scope()
  caller-scope

def apply-bindings(expr bindings)
  (if
    !cons?.expr
      (or (lookup-or-eval expr bindings)
          expr)
    quote?:car.expr
      expr
    backquote?:car.expr
      (apply-comma-bindings cdr.expr bindings)
    :else
      (cons (apply-bindings car.expr bindings)
            (apply-bindings cdr.expr bindings)))

def apply-comma-bindings(expr bindings)
  (if
    !cons?.expr
      expr
    unquote?:car.expr
      (apply-bindings cdr.expr bindings)
    :else
      (cons (apply-comma-bindings car.expr bindings)
            (apply-comma-bindings cdr.expr bindings)))

def inline(calls bindings)
  collect:each call calls
    if (or !call !cons?.call)
      yield call
      let f (or (if (sym? car.call)
                  (lookup-binding car.call bindings))
                car.call)
        if (or ~callable?.f compiled-fn?.f)
          yield call
          each x (inline (apply-bindings body.f (cons (as table (gen-bindings sig.f cdr.call)) env.f))
                         (if env.f (cons env.f bindings) bindings))
            yield x



;; internals

def gen-bindings(params args acc)
  (if
    !params ; base case
      acc
    ~cons?.params ; rest param
      (cons (list params (cons 'list args))
            acc)
    (and quote?:car.params ~cons?:cdr.params) ; quoted rest param
      (cons (list cdr.params (cons 'list args))
            acc)
    (~cons? car.params)
      (cons (list car.params car.args)
            (gen-bindings cdr.params cdr.args acc))
    :else ; destructured param
      (gen-bindings car.params car.args
               (gen-bindings cdr.params cdr.args acc)))

def apply-bindings(expr bindings)
  if !cons?.expr
    (or (lookup-binding expr bindings) expr)
    (cons (apply-bindings car.expr bindings)
          (apply-bindings cdr.expr bindings))

def lookup-binding(sym bindings)
  (if
    !bindings
      nil
    !cons?.bindings
      bindings.sym
    :else
      (or (lookup-binding sym car.bindings)
          (lookup-binding sym cdr.bindings)))

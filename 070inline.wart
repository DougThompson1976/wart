def inline(calls bindings)
  (strip-listq:inline-sub calls bindings)

def inline-sub(calls bindings)
  collect:each call calls
    if (or !call !cons?.call)
      yield call
      let f (or (if
                  (sym? car.call)
                    (lookup-binding car.call bindings)
                  (match '(fn . _) car.call)
                    (eval car.call))
                car.call)
        if (or ~callable?.f compiled-fn?.f)
          yield compiled-rules.call
          each x (inline-sub (apply-bindings body.f (cons (as table (gen-bindings sig.f cdr.call)) env.f))
                             (if env.f (cons env.f bindings) bindings))
            yield x



;; Internals

def gen-bindings(params args acc)
  if (and cons?.params quote?:car.params)
    (zap cdr params) ; inline never distinguishes quoted params
  (if
    !params ; base case
      acc
    ~cons?.params ; rest param
      (cons (list params (cons 'listq args))
            acc)
    ~cons?:car.params
      (cons (list car.params car.args)
            (gen-bindings cdr.params cdr.args acc))
    :else ; destructured param
      (gen-bindings car.params car.args
               (gen-bindings cdr.params cdr.args acc)))

def apply-bindings(expr bindings)
  (if
    !cons?.expr
      (or (lookup-binding expr bindings)
          expr)
    quote?:car.expr
      expr
    backquote?:car.expr
      (cons quote (apply-comma-bindings cdr.expr bindings))
    :else
      (cons (apply-bindings car.expr bindings)
            (apply-bindings cdr.expr bindings)))

def lookup-binding(sym bindings)
  (if
    !bindings
      nil
    !cons?.bindings
      bindings.sym
    :else
      (or (lookup-binding sym car.bindings)
          (lookup-binding sym cdr.bindings)))

def apply-comma-bindings(expr bindings)
  (if
    !cons?.expr
      expr
    unquote?:car.expr
      (eval:apply-bindings cdr.expr bindings)
    (match (cons unquote-splice '_) car.expr)
      (join (eval:apply-bindings cdr:car.expr bindings)
            (apply-comma-bindings cdr.expr bindings))
    :else
      (cons (apply-comma-bindings car.expr bindings)
            (apply-comma-bindings cdr.expr bindings)))

def compiled-rules(call)
  (if
    ~cons?.call
      simplify.call
    (iso compiled!if car.call)
      (let x (simplify cadr.call)
        (if
          (iso x cadr.call)
            call
          !x
            doify:inline-sub:list cadr:cddr.call
          :else
            doify:inline-sub:list car:cddr.call))
    (match '(eval _ caller-scope) call)
      (simplify `(eval ,cadr.call))
    :else
      simplify.call)

def simplify(expr)
  (if
    (match '(not _) expr)
      let x compiled-rules:cadr.expr
        (if
          (iso x cadr.expr)
            x
          !x
            1
          :else
            nil)
    (match '(car (listq _ . _)) expr)
      cadr:cadr.expr
    (match '(cdr (listq _ . _)) expr)
      `(listq ,@cddr:cadr.expr)
    ; (eval '_) => _
    (match '(eval _) expr)
      let expr2 compiled-rules:cadr.expr
        if (and cons?.expr2 quote?:car.expr2)
          (compiled-rules cdr.expr2)
          `(eval ,expr2)
    (and single?.expr
         (match '(fn nil _) car.expr))
      (compiled-rules (car.expr 2))
    :else
      expr)

def doify(x)
  if single?.x
    car.x
    (cons 'do x)

def listq 'args
  args

def strip-listq(tree)
  (if
    (iso 'listq tree)
      'list
    ~cons?.tree
      tree
    :else
      (cons strip-listq:car.tree
            strip-listq:cdr.tree))

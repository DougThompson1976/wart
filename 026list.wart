defcall list(l idx end)
  if (< idx 0)
    = idx (+ len.l idx)
  if (and end (< end 0))
    = end (+ len.l end)
  (list_get l idx end)

defset list((l idx end) val)
  (prn l " " idx " " end " " val)
  (prn
    `(do
;?        if (< ,idx 0)
;?          = ,idx (+ len.,l ,idx)
;?        if (and ,end (< ,end 0))
;?          = ,end (+ len.,l ,end)
       (list_splice ,l ,idx (or ,end (+ ,idx 1)) (if ,end ,val list.,val))))

prn.

;? ;? = l '(1 2 3)
;? ;? prn "===="
;? ;? ;? = f (coerce-quoted l function=)
;? ;? = f (mfn'(l idx end val)
;? ;?       `(list_splice ,l ,idx ,end ,val))
;? ;? prn.f
;? ;? (f l 0 2 nil)
;? ;? prn l
;? 
;? defcoerce list function=
;?   mfn'(l idx end val)
;?     `(list_splice ,l ,idx ,end ,val)
;? prn "===="
= l '(1 2 3)

= (l 0 2) '(4)
prn l
= (l 0) 6
prn l

quit.

def= car(l x)
  (set_car l x)

def= cdr(l x)
  (set_cdr l x)

def rem(f seq)
  if seq
    if (f car.seq)
      (rem f cdr.seq)
      (cons car.seq (rem f cdr.seq))

def keep(f seq)
  (rem ~f seq)

def map(f xs)
  if xs
    (cons (f car.xs)
          (map f cdr.xs))

def reduce(f xs)
  if cddr.xs
    (reduce f (cons (f car.xs cadr.xs)
                    cddr.xs))
    (f @xs)

def all(f xs)
  (and @(map f xs))

def some(f xs)
  (or @(map f xs))
alias any some

def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def zip-flat(a b)
  if (and a b)
    `(,car.a ,car.b ,@(zip-flat cdr.a cdr.b))

def pairwise(xs)
  (zip xs cdr.xs)

def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def lastcons(l)
  aif cdr.l
    lastcons.it
    l

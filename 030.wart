= mac! (mfn '(name params . body)
  `(= ,name (mfn ',params
                    ,@body)))

mac! def!(name params . body)
  `(= ,name (fn ,params ,@body))

mac! do body
  `((fn() ,@body))

def! prn args
  (if args
    (do
      pr car.args
      prn @cdr.args
      car.args)
    (pr "
"))

mac! def(name params . body)
  if bound?.name
    (prn "redef: " name)
  `(def! ,name ,params ,@body)

mac! mac(name params . body)
  if bound?.name
    (prn "redef: " name)
  `(mac! ,name ,params ,@body)

mac alias(new old) ; include later refinements
  `(mac ,new $args
     `(,,old ,@$args))

def compose(f g)
  mfn 'args
    `(,f (,g ,@args))

def complement(f)
  (compose not f)

mac let(var val . body)
  `((fn(,var) ,@body) ,val)

def list args
  if args
    (cons car.args
          (list @cdr.args))

let $iso iso ; ignore later refinements
  def isa(x 't)
    ($iso t type.x)

= cadr car:cdr
= cddr cdr:cdr

def id(_)
  _

= quote (car:car (cons ' 'a))
def quote?(_) (iso _ quote)
= backquote (car '`(1))
def backquote?(_) (iso _ backquote)
= comma (car:cadr '`(,1))
def comma?(_) (iso _ comma)
= comma-splice (car:cadr '`(,@1))
def comma-splice?(_) (iso _ comma-splice)

def die args
  prn @args
  quit.

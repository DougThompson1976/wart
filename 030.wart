= mac! (fn '(name params . body)
  (eval `(= ,name (fn ',params
                    ; remember to update isMacro when changing this
                    (eval ((fn() ,@body))
                          caller-scope)))
        caller-scope))

mac! def!(name params . body)
  `(= ,name (fn ,params ,@body))

mac! do body
  `((fn() ,@body))

def! prn args
  (if args
    (do
      pr car.args
      prn @cdr.args
      car.args)
    (pr "
"))

mac! def(name params . body)
  if bound?.name
    (prn "redef: " name)
  `(def! ,name ,params ,@body)

mac! mac(name params . body)
  if bound?.name
    (prn "redef: " name)
  `(mac! ,name ,params ,@body)

mac alias(new old)  ; include later refinements
  `(mac ,new $args
     `(,,old ,@$args))

def compose(f g)
  fn 'args
    eval `(,f (,g ,@args)) caller-scope

def complement(f)
  (compose not f)

mac let(var val . body)
  `((fn(,var) ,@body) ,val)

def list args
  if args
    (cons car.args
          (list @cdr.args))

let $iso iso ; ignore later refinements
  def isa(x 't)
    ($iso t type.x)

= cadr car:cdr
= cddr cdr:cdr

def id(_)
  _
alias present? id

= quote (car:car (cons ' 'a))
def quote?(_) (iso _ quote)
def quoted?(_) (quote? car._)
= backquote (car '`(1))
def backquote?(_) (iso _ backquote)
def backquoted?(_) (backquote? car._)
= unquote (car:cadr '`(,1))
def unquote?(_) (iso _ unquote)
def unquoted?(_) (unquote? car._)
= unquote-splice (car:cadr '`(,@1))
def unquote-splice?(_) (iso _ unquote-splice)
def unquote-spliced?(_) (unquote-splice? car._)
= splice (car '@1)
def splice?(_) (iso _ splice)
def spliced?(_) (splice? car._)

def die args
  prn @args
  quit.

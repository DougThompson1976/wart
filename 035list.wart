(redef cut(l start end)
  (let n len.l
    (or= start 0)
    (or= end n)
    (if (< start 0)
      (= start (+ n start)))
    (if (<= end 0)
      (= end (+ n end)))
    (subseq l start end)))

(defcall cons(l index)
  (car (cut l index 1+.index)))

(defcall cons(l start end)
  (cut l start end))

(defset cons(l index val)
  (if (< index 0)
    (= index (+ len.l index)))
  (= (elt l index)
     val))

(defset cons(l start end newlist)
  (let n len.l
    (or= start 0)
    (or= end 0)
    (if (< start 0)
      (= start (+ n start)))
    (if (<= end 0)
      (= end (+ n end)))
    (if
      (and no.newlist (iso start 0) (>= end n))
        (err "BUG: cannot delete entire list by writing to list slice")
      (and no.newlist (iso start 0))
        (do (= (car l) (nth end l))
            (= (cdr l) (set-slice cdr.l 0 end nil)))
      (and newlist (iso start 0))
        (do (= (car l) car.newlist)
            (= (cdr l) (set-slice cdr.l 0 1-.end cdr.newlist)))
      :else
        (= (cdr l) (set-slice cdr.l 1-.start 1-.end newlist)))))

(def set-slice(l start end newlist ? curr 0)
  (if
    (no l)
      nil
    (< curr start)
      (cons car.l (set-slice cdr.l start end newlist 1+.curr))
    (and (<= start curr) (< curr end))
      (if newlist
        (cons car.newlist (set-slice cdr.l start end cdr.newlist 1+.curr))
        (set-slice cdr.l start end nil 1+.curr))
    (<= end curr)
      (cons car.l (set-slice cdr.l start end newlist 1+.curr))))

(redef len(x)
  (if x
    (length (as cons x))
    0))

(def empty(x)
  (no x))

(def testify(x) :type 'cons
  [find _ x])

(def wart-last(xs)
  (if (cdr xs)
    (wart-last cdr.xs)
    (car xs)))
(defover last wart-last)

(def consif(x y)
  (if x
    (cons x y)
    y))

(alias copy copy-seq)

(def alist(list-of-pairs)
  (map0 (fn((x y)) (cons x y)) list-of-pairs))

(def dot((a b))
  (cons a b))



(def mappend(f . args)
  (apply 'join (apply 'map0 (as function f) args)))

(def intersperse(x ys ? as 'cons)
  (if ys
    (coerce (cons car.ys
                  (mappend [list x _] cdr.ys))
            as)))

(def split(seq pos)
  (list (cut seq 0 pos) (cut seq pos)))

(def reclist(f xs)
  (and xs
       (or (call f xs)
           (reclist f cdr.xs))))
(def reclist(f s) :case (not listp.s)
  (reclist f (as cons s)))

(def wart-some(f seq)
  (reclist f^car seq))
(defover some wart-some)

(def all(test xs)
  (call ~some ~testify.test xs))

(def mem(test seq)
  (reclist [if (call testify.test car._) _]
           seq))

(defover keep wart-keep)
(def keep(f seq)
  (if seq
    (coerce
      (keep f (as cons seq))
      type.seq)))

(def keep(f seq) :case consp.seq
  (acase car.seq
    f     (cons it (keep f cdr.seq))
    :else (keep f cdr.seq)))

(def wart-rem(test seq)
  (keep ~testify.test seq))
(defover rem wart-rem)

(def trues(f xs)
  (and xs
       (iflet fx (call f car.xs)
          (cons fx (trues f cdr.xs))
          (trues f cdr.xs))))

(redef join args
  (apply 'concatenate (type (car (rem nil args))) args))

(def pos(test s ? idx 0)
  (position-if testify.test s :start idx))
(def rpos(test s ? idx 0)
  (position-if testify.test s :from-end t :start idx))

(def wart-map(f . seqs)
  (if (subtypep (type car.seqs)
                'sequence)
    (apply 'map0 f seqs)
    (apply f seqs)))
(defover map wart-map)

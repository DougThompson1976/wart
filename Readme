  If I look at any small part of it, I can see what is going on -- I don't
  need to refer to other parts to understand what something is doing.

  If I look at any large part in overview, I can see what is going on -- I
  don't need to know all the details to get it.

  Every level of detail is as locally coherent and as well thought-out as any
  other level.

      -- Richard Gabriel, The Quality Without A Name
         (http://dreamsongs.com/Files/PatternsOfSoftware.pdf, page 42)

Wart is a small, *super* readable, thoroughly unit-tested lisp.
Wart returns to the roots of lisp: no constraints, maximum flexibility, extreme late-binding.
Wart is not a platform. It exposes no interface, releases no version numbers.
Anything can change at any time. If you use it, write lots of tests. Or God help you.
Everything is open to question -- but you'll have to pry macros out of my cold dead hands.

Wart is intended above all to be read.
If you write programs using it, put them in this directory. Don't hide wart away
somewhere in your path.
Feel free to make changes to the language. You know your needs best.

Wart will eventually be 'fast enough'. Right now it's 3-5 orders of magnitude too slow.
It will always be small. 10-20kLoC should provide a useable foundation for 'real' apps.

---

As a code sample, factorial in wart:

  def fact(n)
    if (iso n 0)                        ; iso is wart's comparison operator
      1
      (n * (fact n-1))

  ; Alternatively
  def fact(n)
    (n * (fact n-1))
  def fact(n) :case (iso n 0)
    1

All functions are generic and can be extended or overridden at any time. The
implementation uniformly adds features to language primitives by extending
them in this manner.

  def len(x) :case (isa x queue)
    (queue-length x)

Other features: first-class macros that are also open to extension, pervasive
python-style keyword arguments, and a cleaner syntax than traditional lisp.

You'll need linux and gcc.

To run it:
  $ git clone https://github.com/akkartik/wart.git
  $ cd wart
  $ ./wart
  wart>

Hit <enter> twice to eval.
Hit ctrl-d to quit.

To run tests:
  $ wart test
  $ # success

Wart started out as a Common Lisp implementation, which may be an easier read
if you aren't fluent with C: http://github.com/akkartik/wart/tree/sbcl

I love feedback: wart@akkartik.com

--- Optional parens

Wart is indentation sensitive. Multi-word lines without leading parens are
implicitly grouped with later indented lines:
  if (> n 0)
    * n (- n 1)
=>
  (if (> n 0)
    (* n (- n 1))

No indented lines after? They're grouped in isolation:
  a b
  c d
=>
  (a b)
  (c d)

Lines with a single word are never wrapped in parens:
  def foo()
    x
=>
  (def foo()
    x)    ; x is returned as a value, never called

Lines with a leading paren are never wrapped in parens:
  def foo(x)
    (prn x) x
=>
  (def foo(x)
    (prn x) x)

Putting these rules together, parens are not required around 'if' in:
  if (iso 1 x%2)
    'odd
    'even
..but they are required in:
  (if                 ; parens required because line has a single word
    (iso 1 x%2)       ; parens required to avoid grouping with next line
      'odd
    :else             ; optional, sometimes more clear
      'even)
..and, furthermore, this is wrong:
  if (iso 1 x%2)
    'odd
  :else
    'even
=>
  (if (iso 1 x%2)
    'odd)
  :else
  'even               ; wrong

--- "But I hate significant whitespace!"

I'm not trying to minimize parens typed; I'm trying to make lisp code more
readable to non-lispers. Wart's codebase tastefully removes parens from just
control-flow operators (def/mac/if/while/..), leaving them alone everywhere
else. When in doubt, I insert parens.

If you don't like this approach, just use parens everywhere:
  (def foo() 34)
  (def foo()
    34)

Indentation-sensitivity is disabled inside parens. This rule is useful if you
want multiple expressions on a single line:
  (if test1 body1     ; parens required to avoid grouping test2 and body2
      test2 body2
            else-expr)

It also implies that backquoted expressions must be fully parenthesized:
  mac when(cond ... body)
    `(if ,cond
       (do ,@body))   ; parens before 'do' are required

--- Infix operators

Unlike other lisps, wart supports infix operators.
  wart> 3 + 1
  4

You don't need spaces around infix ops.
  wart> 3+1
  4

Infix ops don't compromise homoiconicity; wart parses them into lisp forms so
your macros don't have to worry about them:
  wart> 'a+b
  (+ a b)

Infix ops are always left-associative.
  wart> 'a+b+c
  (+ (+ a b) c)

Range comparisons are convenient as long as they return the last arg on
success (because of left-associativity) and pass nils through:
  wart> '(a > b >= c)
  (>= (> a b) c)      ; watch out if b is nil!

  wart> '(< nil 34)
  nil                 ; should always be true
  wart> '(< 34 nil)
  nil                 ; should always be true

You can mix infix ops with regular prefix lisp:
  wart> '(a + (f b))
  (+ a (f b))

  wart> '(fib n-1)
  (fib (- n 1))

Operator precedence is not hardcoded. Instead, there is just one rule:
operators surrounded by whitespace have lower precedence than operators that
are not.
  wart> '(n * n-1)
  (* n (- n 1))

You can create your own infix ops:

  def (<>) (a b)                        ; def <> (a b) would become <> def (a b)
    (~iso a b)

  wart> (1 <> 2)
  1

To permit arbitrary infix ops, wart makes them distinct from regular symbols.
The sets of 'infix chars' and 'symbol chars' are disjoint. This implies that
wart won't let you define some traditional lisp names that you might be used
to:

  wart> '*global*
  ((* global) *)                        ; probably not what you want

  wart> 'uppercase-char-p
  (- uppercase (- char p))              ; probably not what you want

  wart> '(char> a "p")
  ((> char a) p)                        ; probably not what you want

To create multi-word symbols, use underscores or camelCase. I'm trying out
capitalizing globals.

While regular symbols can't be used in infix mode, infix ops can be used like
regular symbols.

  wart> (+ 4 2)
  6

To use an infix op in a higher-level function, wrap it in parens:

  wart> (map ++ '(1 2 3))
  Error: can't increment map

  wart> (map (++) '(1 2 3))                   ; hello haskell!
  (2 3 4)

In addition to the usual arithmetic, wart defines a few infix ops:
  a.b                 ; => (a b) unless a and b are all digits; 2.4 is a number
  f:g                 ; => (compose f g)
  ~f                  ; => (complement f)

Prefix can also be combined with infix, and has highest-precedence because of
the default left-associativity:
  ~f.b                ; => ((complement f) b)

Infix operators can coexist with paren-insertion:

  a +
    b+c * d
=>
  (+ a (* (+ b c) d))

However, if your infix expressions need multiple lines, ask if they're worth
doing in infix. The following is actually harder to read in infix:

  (* some_function.some_argument
     (+ some_other_function.some_other_argument
        some_random_constant))

I prefer to use infix only for simple expressions with short variable names.
And I never use infix in macro expansions. After all, macros are the whole
reason we have s-expressions.

--- Credits

Wart was inspired by Arc, a lisp dialect by Paul Graham and Robert Morris:
  http://www.paulgraham.com/arc.html
It is distributed under the same license as Arc.

Discussions on the Arc Forum generated all the ideas here:
  http://arclanguage.org/forum

Story arc (pun intended):
  "The wart atop the mountain": http://arclanguage.org/item?id=12814
  Generic functions: http://arclanguage.org/item?id=11779, http://arclanguage.org/item?id=13790
  Python-style keyword args: http://arclanguage.org/item?id=12657
  Why wart has no modules: http://arclanguage.org/item?id=12777
  Why wart has just one kind of equality: http://arclanguage.org/item?id=13690
  In praise of late binding: http://arclanguage.org/item?id=15655
  Libraries suck: http://www.arclanguage.org/item?id=13283

Feedback: wart@akkartik.com

(test "iso works by coercing empty tables"
  :valueof (table)
  :should be (table))

(test "iso works on tables"
  :valueof (table 1 2 3 4)
  :should be (table 3 4 1 2))

(setf h (table))
(setf (gethash 0 h) 34)
(test "coercing hash tables to functions works"
  :valueof (type (as function h))
  :should be 'function)

(test "call-fn on hash table works"
  :valueof (call-fn h 0)
  :should be 34)

(test "call on hash tables works"
  :valueof (call h 0)
  :should be 34)

(test "call on hash tables can take a default"
  :valueof (call h 'no-such-key :default 42)
  :should be 42)

(test "apply on hash tables works"
  :valueof (apply h '(0))
  :should be 34)

(test "coercing hash tables to functions in read position"
  :valueof h.0
  :should be 34)

(test "coercing hash to list works"
  :valueof (as cons (ret x (table)
                      (setf (gethash 1 x) 2)
                      (setf (gethash 2 x) 3)))
  :should be '((2 3) (1 2)))

(test "coercing empty hash to list works"
  :valueof (as cons (table))
  :should be nil)

(test "coercing list to hash works"
  :valueof (let x (as hash-table '((1 2) (2 3)))
             (gethash 1 x))
  :should be 2)

(test "coercing list to hash works - 2"
  :valueof (let x (as hash-table '((1 2) (2 3)))
             (gethash 2 x))
  :should be 3)

(test "coerce nil to hash works"
  :valueof (hash-table-count (as hash-table nil))
  :should be 0)

(test "len works on hash tables"
  :valueof (len (table 1 2 3 4))
  :should be 2)

(test "each works on tables"
  :valueof (sort
             (collect
               (let h (table)
                 (= h.1 2 h.3 4)
                 (each (k v) h
                   yield.k)))
             '<)
  :should be '(1 3))

(test "table works with args"
  :valueof (let x (table a 1 b 2)
             x!a)
  :should be 1)

(test "assigning to hash works"
  :valueof (let ans (table)
             (= ans.0 3)
             ans.0)
  :should be 3)

(test "keys works"
  :valueof (sort (keys (table 1 2 3 4)) '<)
  :should be '(1 3))

(test "fill-table has the right length"
  :valueof (let tb (table a 1 b 2)
             (fill-table tb '(c 3 d 4))
             (hash-table-count tb))
  :should be 4)

(test "fill-table contains old keys"
  :valueof (let tb (table a 1 b 2)
             (fill-table tb '(c 3 d 4))
             tb!a)
  :should be 1)

(test "fill-table contains new keys"
  :valueof (let tb (table a 1 b 2)
             (fill-table tb '(c 3 d 4))
             tb!c)
  :should be 3)

(test "fill-table overrides old keys with new ones"
  :valueof (let tb (table a 1 b 2)
             (fill-table tb '(b 45 c 3 d 4))
             tb!b)
  :should be 45)



; integration test: ssyntax + hash
(test "compose works with hash tables"
  :valueof (let h (table 1 3)
             1+^h.1)
  :should be 4)

; integration test: ssyntax + hash + assignment
(test "compose works with assignment"
  :valueof (let h (table 1 3)
             ++^h.1
             h.1)
  :should be 4)

(test "nested compose works with assignment"
  :valueof (let h (table 1 3)
             (list 1+^++^h.1 h.1))
  :should be '(5 4))

; integration test: table + set + iso
(test "setting inside compound structures works"
  :valueof (ret aa (table a '(1 2) b 3)
             (= aa!a.1 34))
  :should be (table a '(1 34) b 3))

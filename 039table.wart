(def iso(x y) :case (isa x 'hash-table)
  (and (iso (length (keys x))
            (length (keys y)))
       (all
         (fn((k v))
           (iso y.k v))
         (coerce x 'cons))))

(defcall hash-table table
  (fn(_ ? default nil)
    (gethash _ table default)))

(defset hash-table(table key value)
  (setf (gethash key table)
        value))

(defcoerce hash-table cons
  (fn(table)
    (ret ans '()
      (maphash (fn(k v)
                 (push (list k v) ans))
               table))))

(defcoerce cons hash-table
  (fn(l)
    (ret ans (table)
      (map0 (fn((a b))
              (= ans.a b))
            l))))

(defcoerce null hash-table
  [table])

(def len(x) :case (isa x 'hash-table)
  (hash-table-count x))

(ignore-redef
(mac table args
  `(as hash-table
       (list ,@(map0 (fn((k v))
                        `(list ',k ,v))
                     pair.args)))))

(def keys(table)
  (ret ans ()
    (maphash (fn(k v)
               (push k ans))
             table)))

(def vals(table)
  (ret ans ()
    (maphash (fn(k v)
               (push v ans))
             table)))

(def fill-table(tb data)
  (map0 (fn((k v))
          (= tb.k v))
        pair.data)
  tb)

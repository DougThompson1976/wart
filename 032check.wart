let $if if
  mac! if args
    $if !cdr.args
      car.args
      `(,$if ,car.args
         ,cadr.args
         (if ,@cddr.args))

mac or args
  if args
    `(let $x ,car.args
       if $x
         $x
         or ,@cdr.args)

mac and args
  if !args
    1
    if !cdr.args
      car.args
      `(if ,car.args
         and ,@cdr.args)

alias nil? not
alias no not

def match(a b bindings)
  or= bindings (table)
  (or (iso a b)
      (iso a '_)                            ; _ matches anything
      (and sym?.a                           ; (_x _x) matches two of anything
           (iso str.a.0 "_")
           (or= bindings.a b)
           (iso bindings.a b))
      (and sym?.a                           ; x_ matches any $x
           (iso str.a.-1 "_")
           (let acore (str.a 0 -1)
             (and (~iso acore str.b)        ; (but not x itself)
                  (iso sym.acore sym-root.b))))
      (and cons?.a cons?.b
           (match car.a car.b bindings)
           (match cdr.a cdr.b bindings)))

let $iso iso
  def! iso(a b)
    or ($iso a b)
      and (cons? a)
          (cons? b)
          (iso car.a car.b)
          (iso cdr.a cdr.b)

def only(f)
  (fn args
    (if f (f @args)))

mac check(x test else)
  `(let $x ,x
     if (,test $x)
      $x
      ,else)

def maybe(f a b/to)
  if a
    (f a b)
    b

mac in(x . choices)
  `(let $x ,x
     (or ,@(map (fn(_) `(iso $x ,_))
                choices)))

def predicate(x)
  (if
    (isa x 'function)
      x
    (iso x :else)
      (fn() 1)
    :else
      (fn(_) (iso x _)))

mac caselet(var expr . branches)
  let expand (afn(branches)
               (if ~cdr.branches
                 car.branches
                 `(if ((predicate ,car.branches) ,var)
                    ,cadr.branches
                    ,(self cddr.branches))))
    `(let ,var ,expr ,expand.branches)

mac case(expr . branches)
  `(caselet $x ,expr ,@branches)

mac acase(expr . branches)
  `(caselet it ,expr ,@branches)

; ignore the uniq part of a sym
def sym-root(x)
  let name (rev:as list str.x)
    while (and name digit?:car.name)
      (zap cdr name)
    (sym @rev.name)

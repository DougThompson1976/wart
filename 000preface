Good programmers write clean, simple codebases. But even good programmers
can't seem to *keep* codebases clean over time. There are several reasons for
this:

X Over time the codebase accumulates constraints its programmers can't
  control. Backwards compatibility considerations, subcomponents that must be
  invoked in a specific order, arranging things to satisfy the build system or
  other tools, etc. As the space of possible changes is increasingly
  constrained, programmers gradually lose their sense of ownership toward the
  codebase. It becomes hard enough to just get the codebase to do what you
  want.

X Codebases with even moderate success acquire new programmers. Even talented
  newcomers don't understand why things are the way they are. They make
  changes that, while internally consistent, go against the grain of the
  design in subtle ways. The owners/veterans start out watching such changes
  closely and guiding newcomers, but over time this becomes harder and harder.
  Once you admit some kinds of ugliness it becomes easier to live with others
  (http://en.wikipedia.org/wiki/Broken_windows_theory). As other constraints
  grow and sense of ownership decays, newcomers get less guidance, more noob
  code is mixed in, and the coherence of the original design is diluted.

X Newcomers gain experience with the codebase in ad hoc ways, with gaps in
  their knowledge. Their guidance to the next generation is less coherent
  still, and may even contradict the original authors.

X As the original coherence decays, the quality of the codebase decays as
  well. The original design principles become less and less useful,
  accelerating their demise.

This trajectory shows two sources of entropy: shifting requirements that make
the once-ideal design less ideal, and in transmitting even an ideal design to
newcomers. Both sources of entropy can be attacked with a single imperative:
make rewrites easier and less risky.

- Write lots of tests. Tests can't avoid bugs, but they should guard against
  *known* bugs. The contract: if the tests pass, no regressions have been
  introduced.

  Tests help newcomers read an unfamiliar codebase. "Why is this not written
  like that?" Try it, run tests. What failed? "Ah, I hadn't thought of feature
  x."

- Tier tests into levels, and make each level of tests coherent and
  self-contained.

  Layered tests simplify major redesign experimenting. Just throw out
  sub-components *and all their tests* without fear of regressions.

  Layering also helps organize the knowledge encoded in tests into a higher
  structure that is easier for outsiders to read.

- Keep the programmer fully in control.
  - Declarations in any order.
  - All primitives open to extension or overriding.
  - No backwards compatibility guarantees for programmers. Expect app-level
    tests to warn of errors after upgrading libraries.

  This helps maintain programmers' sense of ownership and motivation. It also
  fosters accountability; with complete flexibility there's less excuse for
  convoluted APIs, for codebase layout to not reflect program behavior.

- Document as concisely as possible the constraints that drove the design.
  Focus on what you guard against, not what the implementation does. (See top
  of tokenize.cc for an example.)

  This helps newcomers glimpse the history and the 'theory' of the codebase,
  why things are the way they are. These notes aren't complete, but they
  highlight what's important, and can trigger conversation with veterans. They
  also help outsiders gauge the quality of a codebase. What scenarios did the
  programmers consider? Do they seem comprehensive?

Next: 001organization (http://github.com/akkartik/wart/blob/master/001organization)

Give feedback: wart@akkartik.com

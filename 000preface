Good programmers write clean, simple codebases. But even good programmers
can't seem to *keep* codebases clean over time. There are several reasons for
this:

X Over time the codebase accumulates constraints its programmers can't
  control. Backwards compatibility considerations, subcomponents that must be
  invoked in a specific order, arranging things to satisfy the build system or
  other tools, etc. As the space of possible changes is increasingly
  constrained, programmers gradually lose their sense of ownership toward the
  codebase. It becomes hard enough to just get the codebase to do what you
  want.

X Codebases with even moderate success acquire new programmers. Even talented
  newcomers don't understand why things are the way they are. They make
  changes that, while internally consistent, go against the grain of the
  design in subtle ways. The owners/veterans start out watching such changes
  closely and guiding newcomers, but over time this becomes harder and harder.
  Once you admit some kinds of ugliness it becomes easier to live with others
  (http://en.wikipedia.org/wiki/Broken_windows_theory). As other constraints
  grow and sense of ownership decays, newcomers get less guidance, more noob
  code is mixed in, and the coherence of the original design is diluted.

X Newcomers gain experience with the codebase in ad hoc ways, with gaps in
  their knowledge. Their guidance to the next generation is less coherent
  still, and may even contradict the original authors.

X As the original coherence decays, the quality of the codebase decays as
  well. The original design principles become less and less useful,
  accelerating their demise.

This trajectory shows two sources of entropy: shifting requirements that make
the once-ideal design less ideal, and transmitting even an ideal design to
newcomers. Both sources of entropy can be attacked with a single imperative:
make rewrites easier and less risky. An easy-to-rewrite codebase can respond
to new requirements with radical reorganizations. And it allows newcomers to
test their knowledge by attempting lots of reorganizations in sandboxes.

This project is an ongoing experiment in maintaining a rewrite-friendly stack
without letting the architecture settle into a local optimum. So far I rely
on: an extremely concise, high-level, late bound language to keep the codebase
approachable to newcomers; minimal dependencies and zero compatibility
guarantees to create and foster a sense of ownership; concise lists of
scenarios considered in the design to record lessons learned and encourage
rewrite attempts; thorough tests throughout the stack to supplant
compatibility guarantees and avoid regressions during rewrites.

Next: 001organization (http://github.com/akkartik/wart/blob/master/001organization)

Give feedback: wart@akkartik.com

  You can't really know anything if you just remember isolated facts.
  If the facts don't hang together on a latticework of theory, you don't
  have them in a usable form.

      -- Charlie Munger (http://ycombinator.com/munger.html)


  More than source code, specifications or documentation, a programmer builds
  a theory of how certain affairs will be handled by a computer program.

      -- paraphrasing Peter Naur, Programming as Theory Building
         (http://alistair.cockburn.us/ASD+book+extract%3A+%22Naur,+Ehn,+Musashi%22)


Summarize the symptoms of the software crisis. One hypothesis: programmers
don't all know the same theory. Blind men and elephant.

Can the theory of a codebase be transmitted more easily between programmers?
Most software either makes no attempt to rigorously state what it's trying to
do, or does so using the isolated facts of tests. This codebase is an
experiment in structuring tests into a higher-level organization.

Transmitting theory requires more than just the codebase at hand. Some amount
of the creator's belief system.

Don't add constraints. Rely on programmer taste, and help future programmers
bulk up their taste muscle.

Here's a picture of my backpack: <img>

Flat namespaces. Everything close at hand. Pockets sometimes useful, but ask
if they're truly necessary. They'll increase the odds you'll leave something
there to decay. No sub directories even though the major subsystems could be
so grouped.


  If I look at any small part of it, I can see what is going on -- I don't
  need to refer to other parts to understand what something is doing.

  If I look at any large part in overview, I can see what is going on -- I
  don't need to know all the details to get it.

  Every level of detail is as locally coherent and as well thought-out as any
  other level.

      -- Richard Gabriel, The Quality Without A Name
         (http://dreamsongs.com/Files/PatternsOfSoftware.pdf, page 42)


Outline of the project. Christopher Alexander's theory of 'misfit-driven
design'.

tests help reading a codebase. what does this line do? comment it out and
rerun the tests.

version control helps reading a codebase. this function is too complex; go
back in time to a simpler version that exposes the skeleton.

Misfits for the overall structure:

  avoid getting locked into designs because of the order you chose to build
  features in. redesign is hard; at least make it apparent what the current
  design does. what needs to be duplicated?

  avoiding duplication between adding a file to a project and asking for it to
  be built

  every code file with its own tests

  no constraints but each code file puts the more important stuff first. At
  the bottom are often functions internal to that file, that are seldom called
  elsewhere.

  facilities for the enumeration of past designs, with their tests. so the
  reader can see how the design changed in response to new constraints.

  sets of code files are preceded by high-level tests

  so there's 4 tiers at which tests are grouped:
    design philosophy -- these writeups, currently not tested
    high-level design tests
    tests for individual functions
    tests for 'internal' functions

  keep each tier coherent without relying on lower levels. if an intrepid
  programmer decides to redo some subsystem he can ignore the tests of lower
  levels with a clear conscience. layered defense against regressions.

some transitions are abrupt; this is deliberate. In spite of the volume of
prose, this isn't a novel. It's a design, and abrupt transitions serve to
punctuate the boundaries between subsystems.

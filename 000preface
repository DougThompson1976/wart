=== Preface

  You can't really know anything if you just remember isolated facts.
  If the facts don't hang together on a latticework of theory, you don't
  have them in a usable form.

      -- Charlie Munger (http://ycombinator.com/munger.html)


  More than source code, specifications or documentation, a programmer builds
  a theory of how certain affairs will be handled by a computer program.

      -- paraphrasing Peter Naur
         (http://alistair.cockburn.us/ASD+book+extract%3A+%22Naur,+Ehn,+Musashi%22)

Programming is hard. I think it's hard because of the difficulty of
transmitting the theory of a codebase.

  - We evaluate code for its semantics, not for readability or hackability.
  - Programmers are more focused on building functionality than on readability
    and hackability.
  - New programmers on projects encounter a steep learning curve; tasks such
    as building it, running it, running the tests, building specific features
    -- all these require either persistence or access to experienced
    programmers. These problems grow as codebases grow larger and older.
  - Programmers acquire experience on a codebase in ad hoc fashion. Different
    programmers know different facts about the codebase, have different holes
    in their knowledge, and may believe contradictory facts without realizing
    it. They become blind men to the codebase's elephant
    (http://en.wikipedia.org/wiki/Blind_men_and_an_elephant)
  - As projects grow, no single programmer sees the big picture anymore.
  - As projects accumulate features their parts move in relation to one
    another. Parts that used to work closely together grow apart, and parts
    that seemed unrelated at the start get increasingly coupled. Ideally a
    project would reorganize static code to reflect this changing reality. In
    practice, this rarely happens, and the couplings are another thing new
    programmers must imbibe -- either from their seniors or from painful
    experience.
  - Parnas's theory of information hiding
    (http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf)
    tells us that new feature requirements can radically change the ideal
    design required to support them. Especially since reorganization is hard,
    such redesign rarely happens, and codebases get more and more
    unnecessarily complex as new features are bolted on. Unnecessary
    complexity gets harder to see over time as the current state gets set
    deeper and deeper into its local optimum. But we can observe it indirectly
    through symptoms like proliferating knobs and commandline flags that need
    to be set in error-prone ways to get the system to run. Often errors of
    design are best observed in the externality of deployment processes.
  - Most experience with a codebase does not translate to other codebases.
    Knowing one project well mostly doesn't help with other projects. This
    causes programmers to become even more focused on the short term.

This trajectory can be summarized thus: great things start to decay as people
continue to work on them. We just see the problem more easily in software
because the life-cycle is compressed. Dysfunctions in organizations that
manifest over a decade become apparent in months in software.

Can the theory of a codebase be transmitted more easily between programmers?
Most software either makes no attempt to rigorously state what it's trying to
do, or does so using the isolated facts of tests. This codebase is an
experiment in structuring tests into a higher-level organization. I want to:

a) Make the overall organization instantly obvious to an outsider.

b) Concisely describe the design of sub-components. I try to follow
Christopher Alexander's misfit-driven method for describing designs
(www.amazon.com/Notes-Synthesis-Form-Harvard-Paperbacks/dp/0674627512). Rather
than describe the current solution, I focus on the considerations and
scenarios I thought of in building it.

c) Write comprehensive tests. Most projects fail because they hold too tightly
to a specific solution and ignore its input space. I focus on the input space
and hold the current solution to be secondary. If past bugs are tightly held
radical redesigns can be undertaken without fear of regressions.

d) Make it as easy as possible to move code around in radical ways. Minimize
explicit dependencies, make the build system smart enough to figure them out
automatically.

e) Given flexibility in code ordering, organize the entire project top-down,
with sub-components in separate files, and externally-used functions coming
before internal details in each file.

f) Keep the tests for each level (overall design, subcomponent design, unit
tests, tests of internal details) coherent. This provides layered defense
against regression, but more importantly it allows us to fearlessly throw out
tests for a subcomponent during redesigns that omit it.

g) Maintain and enumerate past designs with their tests. These aren't built to
run on production, but their tests continue to run. This is work in progress.

h) When running top-level tests, make the state of sub-components visible to
the programmer. This feature is useful both for onboarding newcomers to the
codebase, and as an aid to redesigns. If we hold on to history we might avoid
repeating old mistakes. Work on this is not yet begun.

Redesign is hard. It requires freeing one's mind from knowledge of the current
solution to look for alternatives. Often a better design lies over the
horizon; to find it we must cross a hill. To do better we must explore
solutions that might be worse. No tool will do this for us. But perhaps better
codebases and tools will eliminate other distractions and help us focus on the
essence of programming. This codebase is a live case study in such tools, an
exercise in building something useful that is also easy to redesign over time.

Next: 001organization (http://github.com/akkartik/wart/blob/master/001organization)

Give feedback: wart@akkartik.com

  You can't really know anything if you just remember isolated facts.
  If the facts don't hang together on a latticework of theory, you don't
  have them in a usable form.

      -- Charlie Munger (http://ycombinator.com/munger.html)


  More than source code, specifications or documentation, a programmer builds
  a theory of how certain affairs will be handled by a computer program.

      -- paraphrasing Peter Naur, Programming as Theory Building
         (http://alistair.cockburn.us/ASD+book+extract%3A+%22Naur,+Ehn,+Musashi%22)


Summarize the symptoms of the software crisis. One hypothesis: programmers
don't all know the same theory. Blind men and elephant.

Can the theory of a codebase be transmitted more easily between programmers?
Most software either makes no attempt to rigorously state what it's trying to
do, or does so using the isolated facts of tests. This codebase is an
experiment in structuring tests into a higher-level organization.

Transmitting theory requires more than just the codebase at hand. Some amount
of the creator's belief system.

Don't add constraints. Rely on programmer taste, and help future programmers
bulk up their taste muscle.


Outline of the project. Christopher Alexander's theory of 'misfit-driven
design'.

Misfits for the overall structure:

  avoid getting locked into designs because of the order you chose to build
  features in. redesign is hard; at least make it apparent what the current
  design does. what needs to be duplicated?

  avoiding duplication between adding a file to a project and asking for it to
  be built

  every code file with its own tests

  no constraints but each code file puts the more important stuff first. At
  the bottom are often functions internal to that file, that are seldom called
  elsewhere.

  facilities for the enumeration of past designs, with their tests. so the
  reader can see how the design changed in response to new constraints.

  sets of code files are preceded by high-level tests

  so there's 4 tiers at which tests are grouped:
    design philosophy -- these writeups, currently not tested
    high-level design tests
    tests for individual functions
    tests for 'internal' functions

  keep each tier coherent without relying on lower levels. if an intrepid
  programmer decides to redo some subsystem he can ignore the tests of lower
  levels with a clear conscience. layered defense against regressions.

some transitions are abrupt; this is deliberate. In spite of the volume of
prose, this isn't a novel. It's a design, and abrupt transitions serve to
punctuate the boundaries between subsystems.

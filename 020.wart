assign nil? not
assign no nil?

; (mac foo(x) `(+ 1 ,x))) (let x 3 (foo x)) => 4
assign mac (lambda '($name $params . $body)
  eval `(assign ,$name (lambda ',$params
                         (eval ,@$body))))

mac def($name $params . $body)
  `(assign ,$name (lambda ,$params ,@$body))

def cadr(x)
  (car (cdr x))

def cddr(x)
  (cdr (cdr x))

; let x 3 (add x 1) => 4
; let (a . b) (cons 3 4) (add a b) => 7
mac let($var $val . $body)
  `((lambda(,$var) ,@$body) ,$val)

; (if) => nil
; (if 34) => 34
; ((lambda(x) (if x)) 34) => 34
; (if 34 35) => 35
; (assign x 34) (if x 35) => 35
; (if 34 35 36) => 35
; (if nil 35 36) => 36
; (if nil 35 :else 36) => 36
; (if nil 35 36 37) => 37
let $if if
  mac if $args
    $if (no (cdr $args))
      (car $args)
      `(,$if ,(car $args)
         ,(cadr $args)
         (if ,@(cddr $args)))

; (or) => nil
; (or nil) => nil
; (or 3) => 3
; (or nil 3) => 3
; ((lambda(x) (or nil x)) 3) => 3
; (or nil 3 4) => 3
; (or nil (prn 3) (prn 4)) => 3 after printing just 3
mac or $args
  if $args
    `(if ,(car $args)
       ,(car $args)
       (or ,@(cdr $args)))

; (and) => t
; (and nil) => nil
; (and 3) => 3
; (and nil 3) => nil
; (and 3 4) => 4
; ((lambda(x) (and 3 x 4)) nil) => nil
; (and (prn 3) nil) => nil after printing 3
mac and $args
  if (no $args)
    1
    if (car $args)
      if (cdr $args)
        `(if ,(car $args)
           and ,@(cdr $args))
        (car $args)

; (iso 3 3) => 3
; (iso nil nil) => t
; (iso 3 4) => nil
; (iso '(1) '(1)) => '(1)
; (iso '(1) '(1 2)) => nil
def iso(a b)
  or (atom_equal a b)
    and (cons? a)
        (cons? b)
        (iso (car a) (car b))
        (iso (cdr a) (cdr b))

mac do $body
  `((lambda() ,@$body))

mac when($cond . $body)
  `(if ,$cond
     (do ,@$body))

; apply add '(1 2) => 3
; let x '(1 2) (apply add x) => 3
; apply cons '(1 (2)) => (1 2)
def apply(f args)
  (eval `(,f ,@args))

def list args
  if args
    cons (car args)
         apply list (cdr args)

def reduce(f xs)
  if (cddr xs)
    reduce f (cons (f (car xs) (cadr xs)) (cddr xs))
    apply f xs

def + xs
  reduce add xs

def - xs
  reduce subtract xs

def * xs
  reduce multiply xs

def / xs
  reduce divide xs

def % xs
  reduce modulo xs

def map(f xs)
  if xs
    cons (f (car xs))
         map f (cdr xs)

def zip(a b)
  if (and a b)
    cons (list (car a) (car b))
         zip (cdr a) (cdr b)

def pairwise(xs)
  zip xs (cdr xs)

def all(f xs)
  apply and (map f xs)

def some(f xs)
  apply or (map f xs)
assign any some

def > xs
  all (lambda((x y)) (greater x y))
      pairwise xs

def < xs
  all (lambda((x y)) (greater y x))
      pairwise xs

mac ret($var $val . $body)
  `(let ,$var ,$val
     ,@$body
     ,$var)

mac rfn($name $params . $body)
  `(ret ,$name nil
      assign ,$name (lambda ,$params ,@$body))

mac afn($params . $body)
  `(rfn self ,$params ,@$body)

def pair(l)
  (if
    (no l)
      nil
    (no (cdr l))
      (list (list (car l)))
    :else
      (cons (list (car l) (cadr l))
            (pair (cddr l))))

mac with($params . $body)
  `((lambda ,(map car (pair $params))
     ,@$body)
    ,@(map cadr (pair $params)))

(def bar (x) x)

(def foo (x)
  (bar x))

(foo 5)

(let bar nil
  (prn (foo 5)))

assign nil? not
assign no nil?

; (mac foo(x) `(+ 1 ,x))) (let x 3 (foo x)) => 4
assign mac (fn '($name $params . $body)
  eval `(assign ,$name (fn ',$params
                         (eval ,@$body))))

mac def($name $params . $body)
  `(assign ,$name (fn ,$params ,@$body))

; ((compose f g) . args <=> (f (g . args))
; prn:assign x 3 => x=3
; (let a 3 (prn:assign x a)) => x=3
def compose(f g)
  fn '$args
    eval `(,f (,g ,@$args))

def complement(f)
  fn '$args
    eval `(no:,f ,@$args)

mac proc($name $params . $body)
  `(def ,$name ,$params
     ,@$body
     nil)

mac ret($var $val . $body)
  `(let ,$var ,$val
     ,@$body
     ,$var)

mac rfn($name $params . $body)
  `(ret ,$name nil
      assign ,$name (fn ,$params ,@$body))

mac afn($params . $body)
  `(rfn self ,$params ,@$body)



def prn args
  (pr:str @args "
")
  car.args

assign cadr car:cdr
assign cddr cdr:cdr

; let x 3 (+ x 1) => 4
; let (a . b) (cons 3 4) (+ a b) => 7
mac let($var $val . $body)
  `((fn(,$var) ,@$body) ,$val)

; (if) => nil
; (if 34) => 34
; ((fn(x) (if x)) 34) => 34
; (if 34 35) => 35
; (assign x 34) (if x 35) => 35
; (if 34 35 36) => 35
; (if nil 35 36) => 36
; (if nil 35 :else 36) => 36
; (if nil 35 36 37) => 37
let $if if
  mac if $args
    $if (~cdr $args)
      car.$args
      `(,$if ,car.$args
         ,cadr.$args
         if ,@cddr.$args)

; (or) => nil
; (or nil) => nil
; (or 3) => 3
; (or nil 3) => 3
; ((fn(x) (or nil x)) 3) => 3
; (or nil 3 4) => 3
; (or nil (prn 3) (prn 4)) => 3 after printing just 3
mac or $args
  if $args
    `(if ,car.$args
       ,car.$args
       or ,@cdr.$args)

; (and) => t
; (and nil) => nil
; (and 3) => 3
; (and nil 3) => nil
; (and 3 4) => 4
; ((fn(x) (and 3 x 4)) nil) => nil
; (and (prn 3) nil) => nil after printing 3
mac and $args
  if !$args
    1
    if car.$args
      if cdr.$args
        `(if ,car.$args
           and ,@cdr.$args)
        car.$args

; (iso 3 3) => 3
; (iso nil nil) => t
; (iso 3 4) => nil
; (iso '(1) '(1)) => '(1)
; (iso '(1) '(1 2)) => nil
(let $iso iso
  def iso(a b)
    or ($iso a b)
      and ($iso 'list type.a)
          ($iso 'list type.b)
          (iso car.a car.b)
          (iso cdr.a cdr.b))

def list args
  if args
    cons car.args
         list @cdr.args



def pair(l)
  (if
    !l
      nil
    !cdr.l
      list:list car.l
    :else
      (cons (list car.l cadr.l)
            pair cddr.l))

mac with($params . $body)
  `((fn ,(map car pair.$params)
     ,@$body)
    ,@(map cadr pair.$params))

mac do $body
  `((fn() ,@$body))

def rem(f seq)
  (if seq
    (if (~f car.seq)
      (cons car.seq (rem f cdr.seq))
      (rem f cdr.seq)))

def keep(f seq)
  rem ~f seq



mac when($cond . $body)
  `(if ,$cond
     (do ,@$body))

mac unless($cond . $body)
  `(if !,$cond
     (do ,@$body))

mac iflet($var $expr . $branches)
  if !$branches
    $expr
    `(let $tmp ,$expr
       (if $tmp
         (let ,$var $tmp
           ,car.$branches)
         ,(if cdr.$branches
            `(iflet ,$var ,@cdr.$branches))))

mac aif($expr . $branches)
  `(iflet it ,$expr ,@$branches)

mac whenlet($var $test . $body)
  `(iflet ,$var ,$test
      (do ,@$body))

mac whenlet($var $test . $body)
  `(let ,$var ,$test
     (when ,$var
       ,@$body))

mac awhen($test . $body)
  `(whenlet it ,$test
      ,@$body)

; while (> x 0) prn.x (assign x (- x 1))
mac while($test . $body)
  `(when ,$test
     ,@$body
     (while ,$test ,@$body))

mac whilet($var $test . $body)
  `(let ,$var nil
     (while (assign ,$var ,$test)
        ,@$body))

mac awhile($test . $body)
  `(whilet it ,$test ,@$body)

mac for($var $start $test $update . $body)
  `(let ,$var ,$start
     (while ,$test
       ,@$body
       ,$update))

mac each($var $expr . $body)
  `(for $foo ,$expr $foo (assign $foo cdr.$foo)
      (let ,$var car.$foo
        ,@$body))

let $table table
  def table args
    ret t ($table)
      (each (k v) pair.args
        (table_set t k v))

def test(msg valueof should expected)
  if (should valueof expected)
    (pr ".")
    (do
      (incFailures)
      (prn)
      (prn "F " msg)
      (prn "  got " valueof))
assign be iso



def zip(a b)
  if (and a b)
    cons (list car.a car.b)
         zip cdr.a cdr.b

def pairwise(xs)
  zip xs cdr.xs

def map(f xs)
  if xs
    cons (f car.xs)
         map f cdr.xs

def reduce(f xs)
  if cddr.xs
    reduce f (cons (f car.xs cadr.xs)
                   cddr.xs)
    f @xs

def all(f xs)
  and @(map f xs)

def some(f xs)
  or @(map f xs)
assign any some



let $+ +
  def + xs
    reduce $+ xs

let $- -
  def - xs
    reduce $- xs

let $* *
  def * xs
    reduce $* xs

let $/ /
  def / xs
    reduce $/ xs

let $% %
  def % xs
    reduce $% xs

let $> >
  def > xs
    all (fn((x y)) ($> x y))
        pairwise.xs

  def < xs
    all (fn((x y)) ($> y x))
        pairwise.xs
assign exceed >

assign nil? not
assign no nil?

; (mac foo(x) `(+ 1 ,x))) (let x 3 (foo x)) => 4
assign mac (mfn '($name $params . $body)
  `(assign ,$name (mfn ',$params
                    ,@$body)))

mac def($name $params . $body)
  `(assign ,$name (fn ,$params ,@$body))

; ((compose f g) . args <=> (f (g . args))
; prn:assign x 3 => x=3
; (let a 3 (prn:assign x a)) => x=3
def compose(f g)
  mfn '$args
    `(,f (,g ,@$args))

def complement(f)
  (compose no f)

mac do $body
  `((fn() ,@$body))

mac proc($name $params . $body)
  `(def ,$name ,$params
     ,@$body
     nil)

mac ret($var $val . $body)
  `(let ,$var ,$val
     ,@$body
     ,$var)

mac rfn($name $params . $body)
  `(ret ,$name nil
      assign ,$name (fn ,$params ,@$body))

mac afn($params . $body)
  `(rfn self ,$params ,@$body)



def prn args
  (pr (str @args "
"))
  car.args

assign cadr car:cdr
assign cddr cdr:cdr

; let x 3 (+ x 1) => 4
; let (a . b) (cons 3 4) (+ a b) => 7
mac let($var $val . $body)
  `((fn(,$var) ,@$body) ,$val)

let $if if
  mac if $args
    $if (~cdr $args)
      car.$args
      `(,$if ,car.$args
         ,cadr.$args
         (if ,@cddr.$args))

mac or $args
  if $args
    `(let $x ,car.$args
       if $x
         $x
         or ,@cdr.$args)

mac and $args
  if !$args
    1
    if car.$args
      if !cdr.$args
        car.$args
        `(if ,car.$args
           and ,@cdr.$args)

let $iso iso
  def iso(a b)
    or ($iso a b)
      and ($iso 'list type.a)
          ($iso 'list type.b)
          (iso car.a car.b)
          (iso cdr.a cdr.b)

def list args
  if args
    (cons car.args
          (list @cdr.args))

def test(msg valueof should expected)
  if (should valueof expected)
    (pr "|")
    (do
      (incFailures)
      (prn)
      (prn "F " msg)
      (prn "  got " valueof))

def pending-test'(msg valueof should expected)
  prn.
  (prn "pending: " msg)

assign be iso



def pair(l)
  (if
    !l
      nil
    !cdr.l
      (list:list car.l)
    :else
      (cons (list car.l cadr.l)
            pair cddr.l))

mac with($params . $body)
  `((fn ,(map car pair.$params)
     ,@$body)
    ,@(map cadr pair.$params))

mac withs($params . $body)
  if !$params
    `(do ,@$body)
    `(let ,car.$params ,cadr.$params
       (withs ,cddr.$params ,@$body))

mac do1 $body
  `(ret $ret ,car.$body
     ,@cdr.$body)

def rem(f seq)
  if seq
    if (f car.seq)
      (rem f cdr.seq)
      (cons car.seq (rem f cdr.seq))

def keep(f seq)
  (rem ~f seq)



mac when($cond . $body)
  `(if ,$cond
     (do ,@$body))

mac unless($cond . $body)
  `(if !,$cond
     (do ,@$body))

mac iflet($var $expr . $branches)
  if !$branches
    $expr
    `(let $tmp ,$expr
       if $tmp
         (let ,$var $tmp
           ,car.$branches)
         ,(if cdr.$branches
            `(iflet ,$var ,@cdr.$branches)))

mac aif($expr . $branches)
  `(iflet it ,$expr ,@$branches)

mac whenlet($var $test . $body)
  `(iflet ,$var ,$test
      (do ,@$body))

mac whenlet($var $test . $body)
  `(let ,$var ,$test
     when ,$var
       ,@$body)

mac awhen($test . $body)
  `(whenlet it ,$test
      ,@$body)

; while (> x 0) prn.x (assign x (- x 1))
mac while($test . $body)
  `(when ,$test
     ,@$body
     while ,$test
       ,@$body)

mac whilet($var $test . $body)
  `(let ,$var nil
     while (assign ,$var ,$test)
       ,@$body)

mac awhile($test . $body)
  `(whilet it ,$test
     ,@$body)

mac for($var $start $test $update . $body)
  `(let ,$var ,$start
     while ,$test
       ,@$body
       ,$update)

mac each($var $expr . $body)
  `(for $i ,$expr $i (zap cdr $i)
      let ,$var car.$i
        ,@$body)

mac repeat($n . $body)
  `(for $i 0 (< $i ,$n) ++.$i
     ,@$body)



let $table table
  def table args
    ret t ($table)
      each (k v) pair.args
        (table_set t k v)



def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def pairwise(xs)
  (zip xs cdr.xs)

def map(f xs)
  if xs
    (cons (f car.xs)
          (map f cdr.xs))

def reduce(f xs)
  if cddr.xs
    (reduce f (cons (f car.xs cadr.xs)
                    cddr.xs))
    (f @xs)

def all(f xs)
  (and @(map f xs))

def some(f xs)
  (or @(map f xs))

assign any some

mac zap($f $x)
  `(assign ,$x (,$f ,$x))

mac push($x $xs)
  `(assign ,$xs (cons ,$x ,$xs))

mac pop($xs)
  `(do1
     (car ,$xs)
     (zap cdr ,$xs))

def rev(xs acc)
  if !xs
    acc
    (rev cdr.xs
         (cons car.xs acc))

def len(l)
  if l
    (+ 1 (len cdr.l))
    0

def lastcons(l)
  aif cdr.l
    lastcons.it
    l



def tag(type val)
  (list 'type type val)

def rep(x)
  if (iso 'type car.x)
    (list_get x 2)
    x



def queue(l)
  (tag 'queue (list l lastcons.l len.l))

def enq(x q)
  ret x
    let (l last len) rep.q
      (list_set rep.q 2 (+ len 1))
      if !l
        (list_set rep.q 1
                  (list_set rep.q 0 list.x))
        (do
          (set_cdr last list.x)
          (list_set rep.q 1 cdr.last))

def deq(q)
  let (l last len) rep.q
    ret ans car.l
      unless zero?.len
        (list_set rep.q 2 (- len 1))
      (list_set rep.q 0 cdr.l)



mac collect $body
  `(withs ($acc   (queue)
           yield  (fn(_)
                    (enq _ $acc)))
     ,@$body
     (car rep.$acc))

assign cons? _isCons

assign nil? _isNil
assign not nil?
assign no nil?

assign macex (lambda '(name params . body)
  `(assign ,name (lambda ',params
                   (eval ((lambda() ,@body))))))

assign mac (elambda '(name params . body)
  `(assign ,name (elambda ',params
                   ,@body)))

mac def(name params . body)
  `(assign ,name (lambda ,params ,@body))

def cadr(x)
  (car (cdr x))

def cddr(x)
  (cdr (cdr x))

; (if) => nil
; (if 34) => 34
; ((lambda(x) (if x)) 34) => 34
; (if 34 35) => 35
; (assign x 34) (if x 35) => 35
; (if 34 35 36) => 35
; (if nil 35 36) => 36
; (if nil 35 36 37) => 37
mac if args
  _if (no (cdr args))
    (car args)
    `(_if ,(car args)
       ,(cadr args)
       (if ,@(cddr args)))

; (or) => nil
; (or nil) => nil
; (or 3) => 3
; (or nil 3) => 3
; ((lambda(x) (or nil x)) 3) => 3
; (or nil 3 4) => 3
; (or nil (_prn 3) (_prn 4)) => 3 after printing just 3
mac or args
  if args
    `(if ,(car args)
       ,(car args)
       (or ,@(cdr args)))

; (and) => t
; (and nil) => nil
; (and 3) => 3
; (and nil 3) => nil
; (and 3 4) => 4
; ((lambda(x) (and 3 x 4)) nil) => nil
; (and (_prn 3) nil) => nil after printing 3
mac and args
  if (no args)
    1
    if (car args)
      if (cdr args)
        `(if ,(car args)
           and ,@(cdr args))
        (car args)

; (iso 3 3) => 3
; (iso nil nil) => t
; (iso 3 4) => nil
; (iso '(1) '(1)) => '(1)
; (iso '(1) '(1 2)) => nil
def iso(a b)
  or (_atom_equal a b)
    and (cons? a)
        (cons? b)
        (iso (car a) (car b))
        (iso (cdr a) (cdr b))

mac do body
  `((lambda() ,@body))

mac when(cond . body)
  `(if ,cond
     (do ,@body))

; let x 3 (add x 1) => 4
; let (a . b) (cons 3 4) (add a b) => 7
mac let(var val . body)
  `((lambda(,var) ,@body) ,val)

; apply add '(1 2) => 3
; let x '(1 2) (apply add x) => 3
def apply(f args)
  (eval `(,f ,@args))

def list args
  if args
    cons (car args)
         apply list (cdr args)

def reduce(f xs)
  if (cddr xs)
    reduce f (cons (f (car xs) (cadr xs)) (cddr xs))
    apply f xs

def + xs
  reduce add xs

def - xs
  reduce subtract xs

def * xs
  reduce multiply xs

def / xs
  reduce divide xs

def map(f xs)
  if xs
    cons (f (car xs))
         map f (cdr xs)

def zip(a b)
  if (and a b)
    cons (list (car a) (car b))
         zip (cdr a) (cdr b)

def pairwise(xs)
  zip xs (cdr xs)

def all(f xs)
  apply and (map f xs)

def some(f xs)
  apply or (map f xs)
assign any some

def > xs
  all (lambda((x y)) (greater x y))
      pairwise xs

def < xs
  all (lambda((x y)) (not (greater x y)))
      pairwise xs

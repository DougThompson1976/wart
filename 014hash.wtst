(setf h (table))
(setf (gethash 0 h) 34)
(test-wart "coercing hash tables to functions works"
  :valueof (type (coerce h 'function))
  :should be 'function)

(test-wart "call on hash table works"
  :valueof (call h 0)
  :should be 34)

(test-wart "call* on hash tables works"
  :valueof (call* h 0)
  :should be 34)

(test-wart "apply on hash tables works"
  :valueof (apply h '(0))
  :should be 34)

(test-wart "coercing hash tables to functions in read position"
  :valueof h.0
  :should be 34)

(test-wart "coercing hash to list works"
  :valueof (coerce (ret x (table)
                     (setf (gethash 1 x) 2)
                     (setf (gethash 2 x) 3))
                   'cons)
  :should be '((2 3) (1 2)))

(test-wart "coercing list to hash works"
  :valueof (let x (wart-coerce '((1 2) (2 3)) 'hash-table)
             (gethash 1 x))
  :should be 2)

(test-wart "coercing list to hash works - 2"
  :valueof (let x (wart-coerce '((1 2) (2 3)) 'hash-table)
             (gethash 2 x))
  :should be 3)

(test-wart "coerce nil to hash works"
  :valueof (hash-table-count (coerce nil 'hash-table))
  :should be 0)

(test-wart "obj works"
  :valueof (let x (obj a 1 b 2)
             x!a)
  :should be 1)

(test-wart "assigning to hash works"
  :valueof (let ans (table)
             (= ans.0 3)
             ans.0)
  :should be 3)

; integration test: ssyntax + hash
(test-wart "compose works with hash tables"
  :valueof (let h (obj 1 3)
             1+^h.1)
  :should be 4)

; integration test: ssyntax + hash + assignment
(format t "~a~%" (wt-transform '++^h.1))
(format t "~a~%" (macex1 (wt-transform '++^h.1)))
(test-wart "compose works with macros"
  :valueof (let h (obj 1 3)
             ++^h.1
             h.1)
  :should be 4)
(defmacro 2++(place)
  `(incf (incf ,place)))
(format t "~a~%" (wt-transform '2++^++^h.1))
(format t "~a~%" (macex1 (wt-transform '++^2++^++^h.1)))
;(2++ (incf (h 1)))
(test-wart "nested compose works with macros"
  :valueof (let h (obj 1 3)
             2++^++^h.1
             h.1)
  :should be 5)

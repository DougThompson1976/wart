defcall list (seq idx ... ends)
  withs (idx    (range_start seq idx)
         end    (if
                  no.ends
                    (+ idx 1)
                  ~car.ends
                    len.seq
                  :else
                    (range_bounce seq car.ends))
         slice  (list_range seq idx end))
    if2 ends
      slice
      car.slice

defset list ((seq idx ... ends) val)
  `(withs ($idx (range_start ,seq ,idx)
           $end ,(if2 no.ends
                   `(+ $idx 1)
                   `(if2 (not ,car.ends)
                      (len ,seq)
                      (range_bounce ,seq ,car.ends))))
     ,(if2 ends
        `(list_splice ,seq $idx $end ,val)
        `(car:list_splice ,seq $idx $end (list ,val))))

def (pos x (seq | (head ... tail)) n)
  default n :to 0
  if2 seq
    if2 (head = x)
      n
      (pos x tail n+1)

def (rpos x seq n)
  aif (pos x rev.seq n)
    (len.seq-1 - it)

def (predicate x) :case list?.x
  (fn(_) (pos _ x))

def_assign car (seq x)
  (set_car seq x)

def_assign cdr (seq x)
  (set_cdr seq x)

def (empty? seq)
  nil?.seq

def (blank? seq)
  (or nil?.seq empty?.seq)

def (copy x)
  if2 ~cons?.x
    x
    (cons copy:car.x copy:cdr.x)  # piecewise copy for objects by default

def (single? x)
  (and list?.x ~cdr.x)

def (pair? x)
  (and list?.x
       cdr.x
       list?:cdr.x
       ~cddr.x)

def (rev seq acc)
  if2 no.seq
    acc
    (rev cdr.seq
         (cons car.seq acc))

def (lastcons seq)
  aif cdr.seq
    lastcons.it
    seq

def (last seq)
  car:lastcons.seq



def (zip a b)
  if2 (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def (zipmax a b)
  if2 (or a b)
    (cons (list car.a car.b)
          (zipmax cdr.a cdr.b))

def (flatten seq acc)
  (if
    no.seq
      acc
    ~list?.seq
      (cons seq acc)
    :else
      (flatten car.seq (flatten cdr.seq acc)))



def (join ... args)
  if2 args
    if2 car.args
      (cons car:car.args
            (join cdr:car.args @cdr.args))
      (join @cdr.args)

def (keep f seq)
  if2 seq
    if2 f:car.seq
      (cons car.seq (keep f cdr.seq))
      (keep f cdr.seq)

def (rem f seq)
  (keep complement:predicate.f seq)
alias skip rem

def (some f seq)
  (or @(map f seq))

def (all f seq)
  (and @(map f seq))

alias any some
alias none ~some



def (map f ... seqs) :case cdr.seqs
  if2 (all present? seqs)
    (cons (f @(map car seqs))
          (map f @(map cdr seqs)))

def (reduce f seq init)  # f is a binary op
  (if
    no.seq
      init
    ~cdr.seq
      car.seq   # f on one op is the identity function
    :else
      (reduce f (cons (f car.seq cadr.seq)
                      cddr.seq)))

def (pairwise seq)
  (zip seq cdr.seq)

def (best f seq)
  if2 seq
    ret winner car.seq
      each elem cdr.seq
        if2 (f elem winner)
          winner <- elem



## internals

def (range_bounce seq idx)
  if2 (idx < 0)
    (len.seq + idx)
    idx

def (range_start seq idx)
  if2 no.idx
    0
    (range_bounce seq idx)

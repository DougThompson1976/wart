(defgeneric testify(x)
  (or (function-value x)
      [iso _ x]))
(defmethod testify(x) function
  (function-value x))
(defmethod testify(x) cons
  [find _ x])

(ignore-redef
  (defgeneric len(x)
    (length x)))

(defmethod len(x) hash-table
  (hash-table-count x))

(def empty(x)
  (iso 0 len.x))



(ignore-redef
  (defgeneric* iso(x y)
    (or (equal x y)
        (and (consp x)
             (consp y)
             (iso car.x car.y)
             (iso cdr.x cdr.y)))))

(defmethod iso(x y) hash-table
  (and (iso (len keys.x) (len keys.y))
       (all
         (fn((k v))
           (iso y.k v))
         (coerce x 'cons))))



(defgeneric reclist(f xs)
  (and xs
       (or (call f xs)
           (reclist f cdr.xs))))
(defmethod reclist(f s) string
  :coerce-to-cons)

(def wart-some(f seq)
  (reclist f^car seq))
(defover some wart-some)

(def all(test xs)
  (call ~some ~testify.test xs))

(def mem(test seq)
  (reclist [if (call testify.test car._) _]
           seq))

(deftransform wart-keep(f seq)
  (if (no seq)          nil
      (call f car.seq)  (cons car.seq (keep f cdr.seq))
                        (keep f cdr.seq)))
(defmethod wart-keep(f s) string
  :coerce-to-cons)
(defover keep wart-keep)

(def wart-rem(test seq)
  (keep ~testify.test seq))
(defover rem wart-rem)

(def trues (f xs)
  (and xs
       (iflet fx (call f car.xs)
          (cons fx (trues f cdr.xs))
          (trues f cdr.xs))))

(ignore-redef
  (defgeneric* join args
    (apply 'concatenate (type (last (rem nil args))) args)))

(defgeneric pos(test s ? idx 0)
  (position-if testify.test s :start idx))
(defgeneric rpos(test s ? idx 0)
  (position-if testify.test s :from-end t :start idx))

(defgeneric wart-map(f . seqs)
  (if (subtypep (type car.seqs)
                'sequence)
    (apply 'map0 f seqs)
    (apply f seqs)))
(defover map wart-map)

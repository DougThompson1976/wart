cell* build_cell(ast_node n) {
  new_trace_frame("cell");
  if (n == "") return nil;  // void

  if (is_nil(n)) {
    trace("cell") << "nil";
    return nil;
  }

  if (is_list(n) && n.elems.front() == ")") {
    if (n.elems.size() > 1) RAISE << "Syntax error: ) not at end of expr\n" << die();
    trace("cell") << "nil";
    return nil;
  }

  if (is_atom(n)) {
    errno = 0;
    char* end;
    long v = strtol(n.atom.c_str(), &end, 0);
    if (*end == '\0' && errno == 0) {
      trace("cell") << "num " << v;
      return new_num(v);
    }

    if (n.atom.c_str()[0] == '"') {
      trace("cell") << "string " << n.atom;
      return new_string(n.atom.substr(1, n.atom.length()-2));
    }

    trace("cell") << "sym " << n.atom;
    return new_sym(n.atom);
  }

  list<ast_node>::iterator first = n.elems.begin();
  if (*first == "(") {
    n.elems.pop_front();
    cell* result = build_cell(n);
    trace("cell") << result;
    return result;
  }

  cell* new_form = new_cell();
  set_car(new_form, build_cell(n.elems.front()));

  list<ast_node>::iterator next = first; ++next;
  if (*next == "...") {
    if (next != --n.elems.end())
      set_cdr(new_form, build_cell(*++next));  // dotted pair
    else
      set_cdr(new_form, build_cell(*next));
  }
  else if (is_quote_or_unquote(*first) && n.elems.size() == 2) {
    set_cdr(new_form, build_cell(*next));  // dotted pair
  }
  else {
    n.elems.pop_front();
    if (n.elems.empty())
      RAISE << "Error in parsing " << n << '\n' << die();
    set_cdr(new_form, build_cell(n));
  }

  trace("cell") << new_form;
  return new_form;
}

bool is_nil(const ast_node& n) {
  return n.atom == "nil"
      || (n.elems.size() == 2 && n.elems.front() == "(" && n.elems.back() == ")");
}

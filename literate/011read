:(code)
// construct a tree of cells out of next expr in input
cell* read(istream& in) {
  return build_cell(next_ast_node(in));  // see parse, build
}

:(before "End Types")
extern struct cell* nil;  // special value to indicate false or no-value

struct cell {
  cell* car;  // aliased to long or float
  cell* cdr;

  // ints save space on 64-bit platforms
  int type;
    #define CONS 0
    #define INTEGER 1
    #define SYMBOL 2
    #define STRING 3

  cell() :car(NULL), cdr(NULL), type(CONS) {}
  void init() {
    car=cdr=nil, type=CONS;
  }
};

:(code)
// cells are designed to minimize fragmentation on the heap
void test_cell_layout_constraints() {
  cell c;
  CHECK((sizeof(c.car)%4) == 0);
  CHECK((sizeof(c.cdr)%4) == 0);
  CHECK((sizeof(c.type)%4) == 0);

  CHECK(sizeof(long) <= sizeof(cell*));
  CHECK(sizeof(float) <= sizeof(cell*));
  CHECK(sizeof(size_t) <= sizeof(cell*));
}

cell* nil = new cell;
void setup_nil() {
  nil->car = nil->cdr = nil;
}
:(before "End Setup")
setup_nil();
:(code)
void test_pointers_from_nil_are_always_nil() {
  CHECK_EQ(nil->car, nil);
  CHECK_EQ(nil->cdr, nil);
}

// helper: print cells in traces, scenarios
ostream& operator<<(ostream& os, cell* c) {
  if (c == NULL) return os << "NULLNULLNULL";  // error
  if (c == nil) return os << "nil";
  switch(c->type) {
  case CONS:
    if (car(c) == new_sym("'"))
      return os << car(c) << cdr(c);
    os << "(" << car(c);
    for (cell* curr = cdr(c); curr != nil; curr = cdr(curr)) {
      if (is_cons(curr))
        os << " " << car(curr);
      else
        os << " ... " << curr;
    }
    return os << ")";
  case INTEGER:
    return os << to_int(c);
  case SYMBOL:
    return os << to_string(c);
  case STRING:
    return os << "\"" << to_string(c) << "\"";
  default:
    cerr << "Can't print type " << c->type << '\n' << die();
    return os;
  }
}

cell* read(string s) {
  istringstream in(s);
  return read(in);
}

// How cells can represent the different types.

// Numbers, strings and symbols contain the value in the car, and nil in the cdr.
void test_number_cell() {
  cell* x = read("4");
  CHECK_EQ(x->type, INTEGER);
  CHECK_EQ((long)x->car, 4);
  CHECK_EQ(x->cdr, nil);
}

void test_symbol_cell() {
  cell* x = read("abc");
  CHECK_EQ(x->type, SYMBOL);
  CHECK_EQ(*(string*)x->car, "abc");
  CHECK_EQ(x->cdr, nil);
}

void test_string_cell() {
  cell* x = read("\"abc\"");
  CHECK_EQ(x->type, STRING);
  CHECK_EQ(*(string*)x->car, "abc");
  CHECK_EQ(x->cdr, nil);
}

// Lists are constructed out of CONS cells, with the car containing the first
// element and the cdr recursively pointing to the rest.
//
// 'cons', 'car' and 'cdr' are special names. We can construct lists with them
// and (later) much more.
void test_list_of_cells() {
  cell* x = read("(1 2 3)");
  CHECK_EQ(x->type, CONS);
  CHECK_EQ(car(x), new_num(1));
  CHECK_EQ(cdr(x)->type, CONS);
  CHECK_EQ(car(cdr(x)), new_num(2));
  CHECK_EQ(cdr(cdr(x))->type, CONS);
  CHECK_EQ(car(cdr(cdr(x))), new_num(3));
  CHECK_EQ(cdr(cdr(cdr(x))), nil);
}

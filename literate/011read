:(code)
// construct a tree of cells out of next expr in input
cell* read(istream& in) {
  return build_cell(next_ast_node(in));  // see parse, build
}

:(before "End Types")
extern struct cell* nil;

struct cell {
  cell* car;  // aliased to long or float
  cell* cdr;

  // ints save space on 64-bit platforms
  int type;
    #define CONS 0
    #define INTEGER 1
    #define SYMBOL 2
    #define STRING 3

  cell() :car(NULL), cdr(NULL), type(CONS) {}
  void init() {
    car=cdr=nil, type=CONS;
  }
};

:(code)
// cells are designed to minimize fragmentation on the heap
void test_cell_layout_constraints() {
  cell c;
  CHECK((sizeof(c.car)%4) == 0);
  CHECK((sizeof(c.cdr)%4) == 0);
  CHECK((sizeof(c.type)%4) == 0);

  CHECK(sizeof(long) <= sizeof(cell*));
  CHECK(sizeof(float) <= sizeof(cell*));
  CHECK(sizeof(size_t) <= sizeof(cell*));
}

cell* nil = new cell;
void setup_nil() {
  nil->car = nil->cdr = nil;
}
:(before "End Setup")
setup_nil();
:(code)
void test_pointers_from_nil_are_always_nil() {
  CHECK_EQ(nil->car, nil);
  CHECK_EQ(nil->cdr, nil);
}

// helper: print cells in traces, scenarios
ostream& operator<<(ostream& os, cell* c) {
  if (c == NULL) return os << "NULLNULLNULL";  // error
  if (c == nil) return os << "nil";
  switch(c->type) {
  case CONS:
    if (car(c) == new_sym("'"))
      return os << car(c) << cdr(c);
    os << "(" << car(c);
    for (cell* curr = cdr(c); curr != nil; curr = cdr(curr)) {
      if (is_cons(curr))
        os << " " << car(curr);
      else
        os << " ... " << curr;
    }
    return os << ")";
  case INTEGER:
    return os << to_int(c);
  case SYMBOL:
    return os << to_string(c);
  case STRING:
    return os << "\"" << to_string(c) << "\"";
  default:
    cerr << "Can't print type " << c->type << '\n' << die();
    return os;
  }
}

// construct a parse tree of 'cells' for the next expr in input
:(code)
cell* read(istream& in) {
  return build_cell(next_ast_node(in));  // see build
}

:(before "End Types")
// A cell is a binary tree node in the parse tree. It can also represent lists
// and other values.
struct cell {
  // children
  cell* left;
  cell* right;

  int type;           // 'left' contains:
    #define TREE 0    //   a pointer to another cell
    #define SYMBOL 1  //   a name
    #define INTEGER 2 //   a number
    #define STRING 3  //   a list of characters

  // End Cell Fields

  cell() :left(NULL), right(NULL), type(TREE) {}
};

:(code)
// cells are designed to minimize fragmentation on the heap
void test_cell_layout_constraints() {
  CHECK((sizeof(cell)%4) == 0);
  CHECK(sizeof(long) <= sizeof(cell*));
  CHECK(sizeof(float) <= sizeof(cell*));
  CHECK(sizeof(size_t) <= sizeof(cell*));
}

cell* read(string s) {
  istringstream in(s);
  return read(in);
}

//// How cells can represent the different types.

cell* nil = new cell;  // special value to indicate false or empty list

// Numbers, strings and symbols cram their value into the left child and set
// the type appropriately.
void test_number_cell() {
  cell* x = read("4");
  CHECK_EQ(x->type, INTEGER);
  CHECK_EQ((long)x->left, 4);
  CHECK_EQ(x->right, nil);
}

void test_symbol_cell() {
  cell* x = read("abc");
  CHECK_EQ(x->type, SYMBOL);
  CHECK_EQ(*(string*)x->left, "abc");
  CHECK_EQ(x->right, nil);
}

void test_string_cell() {
  cell* x = read("\"abc\"");
  CHECK_EQ(x->type, STRING);
  CHECK_EQ(*(string*)x->left, "abc");
  CHECK_EQ(x->right, nil);
}

// A list is a tree where each element stores its value in the left child, and
// points to the rest of the list in the right.
void test_list_of_cells() {
  cell* x = read("(1 2 3)");
  CHECK_EQ(x->type, TREE);
  CHECK_EQ(left(x), new_num(1));
  CHECK_EQ(right(x)->type, TREE);
  CHECK_EQ(left(right(x)), new_num(2));
  CHECK_EQ(right(right(x))->type, TREE);
  CHECK_EQ(left(right(right(x))), new_num(3));
  CHECK_EQ(right(right(right(x))), nil);
}

// helper: print cells in traces, scenarios
// beware: this code should never call trace, or os could be corrupted
ostream& operator<<(ostream& os, cell* c) {
  if (c == NULL) return os << "NULLNULLNULL";  // error
  if (c == nil) return os << "nil";
  switch(c->type) {
  case TREE:
    if (left(c) == new_sym("'"))
      return os << left(c) << right(c);
    os << "(" << left(c);
    for (cell* curr = right(c); curr != nil; curr = right(curr)) {
      if (is_cell(curr))
        os << " " << left(curr);
      else
        os << " ... " << curr;
    }
    return os << ")";
  case INTEGER:
    return os << to_int(c);
  case SYMBOL:
    return os << to_string(c);
  case STRING:
    return os << "\"" << to_string(c) << "\"";
  default:
    cerr << "Can't print type " << c->type << '\n' << die();
    return os;
  }
}

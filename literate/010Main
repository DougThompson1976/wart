// A bare-bones lisp interpreter. Other features of our language will layer
// atop this versatile core.
//
// Lisp was the original dynamic language, where functions could be defined
// anytime, passed around like any other value, and new code could be
// constructed on the fly.
//
// It matters that it came first only because it indicates that lisp is one of
// the easiest ways to get these features. (http://paulgraham.com/rootsoflisp.html)
//
// These features help us both to organize code for reading and to do with as
// little code as possible. Using just a few core powerful concepts helps
// reduce the learning you have to wade through before you can make changes.
//
// Later we'll show how to create new notations (lisp macros) on the fly that
// are as well-supported as the original notations.
//
//   "In Lisp, you don't just write your program down toward the language, you
//   also build the language up toward your program."
//     -- http://www.paulgraham.com/progbot.html
//
// Lisp isn't perfect or inviolate; we'll be tweaking its rules in later
// files/layers to further strengthen/minimize the core concepts that
// everything else can be built out of.

:(before "End Main")
load_file("init.wart");

:(code)
void load_file(const char* filename) {
  ifstream f(filename);
  if (f.fail()) return;
  run(f);
}

// Run a lisp expression in two stages:
//  a) _read_ the program and turn it into a tree of cells,
//  b) _evaluate_ the tree of cells to yield a result
// To run an entire program, run each expr in sequence, and return the result
// of the final expr.
cell* run(istream& in) {
  cell* result = NULL;
  do {
      result = eval(read(in));
  } while (!eof(in));
  return result;
}

cell* run(string s) {
  stringstream in(s);
  return run(in);
}

:(scenarios run)
:(scenario examples)
# function call; later we'll support a more natural syntax for arithmetic
(+ 1 1)
=> 2
# assignment
(<- x 3)
x
=> 3
# list; deliberately looks just like a function call
'(1 2 3)
=> (1 2 3)
(car '(1 2 3))  # first element
=> 1
(cdr '(1 2 3))  # everything but the first element
=> (2 3)

:(code)
// we might be at eof and just not know it if we haven't looked around yet
bool eof(istream& in) {
  skip_whitespace_and_comments(in);
  in.peek();
  return in.eof();
}

// A bare-bones lisp interpreter. Other features of our language will layer
// atop this versatile core.
//
// Lisp was the original dynamic language; functions didn't have to be defined
// before you referred to them. They just had to exist by the time they were
// called. Code could be constructed dynamically and run. This power fits with
// our goal of ordering code for humans, and fewer constrants make code easier
// to change.
//
// Lisp was also the original higher-order language; functions could be saved
// and passed around just like other values. This powerful feature makes many
// programs shorter.
//
// It doesn't matter for our purposes that it came first; it does matter that
// it likely came first because it was the easiest way to get there, taking
// close to the least possible code. (http://paulgraham.com/rootsoflisp.html)
//
// Lisp remains the only language family where it's convenient to write code
// to generate boilerplate code (using macros; we'll support them later). The
// key insight to enable this is a uniform representation of programs as
// expressions that can be simplified ('evaluated') to yield a result. Core
// features of other languages like conditionals and loops fall out as
// consequences of the simple model for simplifying expressions. As a result,
// variants of these features can be created at will.
//
//   "In Lisp, you don't just write your program down toward the language, you
//   also build the language up toward your program."
//     -- http://www.paulgraham.com/progbot.html

:(before "End Main")
load_file("init.wart");

:(code)
void load_file(const char* filename) {
  ifstream f(filename);
  if (f.fail()) return;
  run(f);
}

// Run a lisp expression in two stages:
//  a) _read_ the program and turn it into a tree of cells,
//  b) _evaluate_ the tree of cells to yield a result
// To run an entire program, run each expr in sequence, and return the result
// of the final expr.
cell* run(istream& in) {
  cell* result = NULL;
  do {
      result = eval(read(in));
  } while (!eof(in));
  return result;
}

cell* run(string s) {
  stringstream in(s);
  return run(in);
}

:(scenarios run)
:(scenario examples)
# function call; later we'll support a more natural syntax for arithmetic
(+ 1 1)
=> 2
# assignment
(<- x 3)
x
=> 3
# list; deliberately looks just like a function call
'(1 2 3)
=> (1 2 3)
(car '(1 2 3))  # first element
=> 1
(cdr '(1 2 3))  # everything but the first element
=> (2 3)

:(code)
// we might be at eof and just not know it if we haven't looked around yet
bool eof(istream& in) {
  skip_whitespace_and_comments(in);
  in.peek();
  return in.eof();
}

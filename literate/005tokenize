:(before "End Types")
typedef string token;

:(code)
token next_token(istream& in) {
  in >> std::noskipws;
  skip_whitespace(in);
  ostringstream out;
  if (in.peek() == '"')
    slurp_string(in, out);
  else
    slurp_word(in, out);

  trace("tokenize") << out.str();
  return token(out.str());
}

// slurp functions read a token when you're sure to be at it
void slurp_word(istream& in, ostream& out) {
  char c;
  while (in >> c) {
    if (isspace(c)) {
      in.putback(c);
      break;
    }
    out << c;
  }
}

void slurp_string(istream& in, ostream& out) {
  slurp_char(in, out);   // initial quote
  char c;
  while (in >> c) {
    out << c;
    if (c == '\\')
      slurp_char(in, out);   // blindly read next
    else if (c == '"')
      break;
  }
}

void slurp_char(istream& in, ostream& out) {
  out << (char)in.get();
}

void skip_whitespace(istream& in) {
  while (isspace(in.peek()))
    in.get();
}

void read_all(string s) {
  stringstream in(s);
  do {
      next_token(in);
  } while (!in.eof());
  // return nothing; we'll just verify the trace
}

:(scenarios read_all)

:(scenario tokenize_breaks_at_whitespace)
34 abc 3.4
-tokenize: 34
-tokenize: abc
-tokenize: 3.4

:(scenario tokenize_handles_string_literals)
34 "abc"
-tokenize: 34
-tokenize: "abc"

:(scenario tokenize_handles_multiple_lines)
34
"abc"
-tokenize: 34
-tokenize: "abc"

:(scenario tokenize_handles_string_with_space)
34
"abc def"
-tokenize: 34
-tokenize: "abc def"

:(scenario tokenize_handles_string_with_escape)
34
"abc \"def"
-tokenize: 34
-tokenize: "abc \"def"

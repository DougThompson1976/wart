//// Tree primitives that we'll extend later.
cell* left(cell* x) {
  if (x->type != TREE) {
    RAISE << "cell has no left child: " << x << '\n';
    return nil;
  }
  return x->left;
}

cell* right(cell* x) {
  return x->right;
}

void set_left(cell* x, cell* y) {
  if (x == nil) {
    RAISE << "set_left on nil\n";
    return;
  }
  x->left = y;
}

void set_right(cell* x, cell* y) {
  if (x == nil) {
    RAISE << "set_right on nil\n";
    return;
  }
  x->right = y;
}

//// Lists are trees when 'sighted along' the right child.
cell* first(cell* x) {
  return left(x);
}

cell* rest(cell* x) {
  return x->right;
}

cell* new_cell(cell* left, cell* right) {
  cell* ans = new_cell();
  set_left(ans, left);
  set_right(ans, right);
  return ans;
}

cell* new_cell(cell* left) {
  return new_cell(left, nil);
}

bool is_cell(cell* x) {  // tree or list?
  return x != nil && x->type == TREE;
}

bool is_atom(cell* x) {
  return x == nil || !is_cell(x);
}

void add_cell(cell* p, cell* x) {
  set_right(p, new_cell(x));
}

//// nil is special; its children point to itself
void setup_nil() {
  nil->left = nil->right = nil;
}
:(before "End Setup")
setup_nil();
:(code)
void test_pointers_from_nil_are_always_nil() {
  CHECK_EQ(nil->left, nil);
  CHECK_EQ(nil->right, nil);
}

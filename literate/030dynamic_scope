// We'd like for function parameters to not override global variables.
:(scenarios run)
:(scenario function_params_create_new_scope)
(<- x 3)
((fn (x) x) 23)
x
=> 3

:(before "End Globals")
unordered_map<cell*, stack<cell*> > Dynamics;
:(replace{} "lookup(cell*")
cell* lookup(cell* sym) {
  if (Dynamics[sym].empty()) {
    RAISE << "No binding for " << to_string(sym) << '\n';
    return nil;
  }
  return Dynamics[sym].top();
}

:(replace{} "new_binding(cell*")
void new_binding(cell* sym, cell* val) {
  if (!Dynamics[sym].empty() && Dynamics[sym].top() == val) return;
  trace("bind") << sym << ": " << val;
  mkref(sym);
  mkref(val);
  Dynamics[sym].push(val);
}

void end_binding(cell* sym) {
  stack<cell*>& bindings = Dynamics[sym];
  if (bindings.empty()) {
    RAISE << "No dynamic binding for " << sym << '\n';
    return;
  }
  trace("unbind") << sym;
  rmref(sym);
  rmref(bindings.top());
  bindings.pop();
}

:(after "Test Teardown")
  teardown_dynamics();
:(code)
void teardown_dynamics() {
  for (unordered_map<cell*, stack<cell*> >::iterator p = Dynamics.begin(); p != Dynamics.end(); ++p) {
    while (!p->second.empty()) {
      rmref(p->first);
      rmref(p->second.top());
      p->second.pop();
    }
  }
}

prn.
(test "to-with-expr works"
 :valueof (to-with-expr '(foo 1 :a 2 (list 3 4) @(list 5 6) 7)
                        (table 'foo (let x 34
                                      (fn(a b (c d) e . f)
                                        (list a b c d e f)))))
 :should be '(withs (x 34)
               (withs ((a b (c d) e . f) (list 1 :a 2 (list 3 4) @(list 5 6) 7))
                 (list a b c d e f))))

(test "to-with-expr passes through unknown calls"
 :valueof (to-with-expr '(foo 1 2) (table))
 :should be '(foo 1 2))

(test "to-with-expr handles nested calls"
 :valueof (to-with-expr '(foo 1 2)
                        (table 'foo (fn(a b)
                                      (bar a b))
                               'bar (fn(c d)
                                      (baz c d))))
 :should be '(withs ()
               (withs ((a b) (list 1 2))
                 (withs ()
                   (withs ((c d) (list a b))
                     (baz c d))))))

(test "to-with-expr skips recursive calls"
 :valueof (to-with-expr '(foo 1 2)
                        (table 'foo (fn(a b)
                                      (foo a b))))
 :should be '(withs ()
               (withs ((a b) (list 1 2))
                 (foo a b))))

(test "to-with-expr skips selectively quoted params"
 :valueof (to-with-expr '(foo x y)
                        (table 'foo (fn('a 'b)
                                      `(+ ,a ,b))))
 :should be '(withs ()
               ((fn('a 'b) `(+ ,a ,b)) x y)))

(test "to-with-expr handles macro calls"
 :valueof (to-with-expr '(foo x y)
                        (table 'foo (fn'(a b)
                                      (eval `(+ ,a ,b) caller-scope))))
 :should be '(withs ()
               (withs ((a b) '(x y))
                  (eval `(+ ,a ,b)))))

(test "to-with-expr leaves alone caller-scope outside macros"
 :valueof (to-with-expr '(foo 1 2)
                        (table 'foo (fn(a b)
                                      (eval a caller-scope))))
 :should be '(withs ()
               (withs ((a b) (list 1 2))
                 (eval a caller-scope))))

(test "to-with-expr handles functions in env"
 :valueof (to-with-expr '(foo x y)
                        (table 'foo (let bar (fn(a b) (+ a b))
                                      (fn(c d)
                                        (bar c d)))))
 :should be `(withs (bar ,(fn(a b) (+ a b)))
               (withs ((c d) (list x y))
                 (withs ()
                   (withs ((a b) (list c d))
                     (+ a b))))))

(test "inline-macro-eval works"
 :valueof (inline-macro-eval '(withs ((a b) '(x y))
                                (eval `(+ ,a ,b))))
 :should be '(withs ((a b) '(x y))
               (+ x y)))

(test "inline-macro-eval works withs intermezzo code"
 :valueof (inline-macro-eval '(withs ((a b) '(x y))
                                (prn a)
                                (eval `(+ ,a ,b))))
 :should be '(withs ((a b) '(x y))
               (prn a)
               (+ x y)))

(test "inline-macro-eval skips explicit list construction"
 :valueof (inline-macro-eval '(withs ((a b) '(x y))
                                (eval (cons '+ a b))))
 :should be '(withs ((a b) '(x y))
               (eval (cons '+ a b))))

(test "inline-macro-eval gives up with unbound vars"
 :valueof (inline-macro-eval '(withs ((a b) '(x y))
                                (eval `(+ ,c ,b))))
 :should be '(withs ((a b) '(x y))
               (eval `(+ ,c ,b))))

(test "inline-macro-eval works with comma expressions without side effects"
 :valueof (inline-macro-eval '(withs ((a b) '(x y))
                                (eval `(+ ,a ,(if 3 b)))))
 :should be '(withs ((a b) '(x y))
               (+ x y)))

(test "inline-macro-eval works with comma-splice expressions without side effects"
 :valueof (inline-macro-eval '(withs (args '(x y))
                                (eval `(+ ,@args 3))))
 :should be '(withs (args '(x y))
               (+ x y 3)))

(test "inline-macro-eval works with nested backquotes"
 :valueof (inline-macro-eval '(withs ((a b) '(x y))
                                (eval `(+ ,a ,(if 3 `(+ 3 ,b))))))
 :should be '(withs ((a b) '(x y))
               (+ x (+ 3 y))))

(test "scope->with-bindings and with-bindings->scope are converses"
 :valueof (with-bindings->scope (scope->with-bindings (table 'x 34)))
 :should be (table 'x 34))

(test "coalesce-bindings works"
 :valueof (coalesce-bindings '(withs (a 3) (withs (b 4) (+ a b) (- a b))))
 :should be '(withs (a 3 b 4) (+ a b) (- a b)))

(test "coalesce-bindings works - 2"
 :valueof (coalesce-bindings '(withs (a 3) (something or other) (withs (b 4) (+ a b) (- a b))))
 :should be '(withs (a 3 b 4) (something or other) (+ a b) (- a b)))

(test "coalesce-bindings works - 3"
 :valueof (coalesce-bindings '(do a b (do c d) (do e f) (do g) h i j))
 :should be '(withs nil a b c d e f g h i j))

(test "mangle-binding renames symbols"
 :valueof (mangle-binding '(= a 2) 'a 'a_2)
 :should be '(= a_2 2))

(test "mangle-binding processes lists of forms"
 :valueof (mangle-binding '((= a 2) (cons a b)) 'a 'a_2)
 :should be '((= a_2 2) (cons a_2 b)))

(test "mangle-binding recurses into subforms"
 :valueof (mangle-binding '(withs (x 1 y 2) (= a 2) (cons a b)) 'a 'a_2)
 :should be '(withs (x 1 y 2) (= a_2 2) (cons a_2 b)))

(test "mangle-binding doesn't touch subforms that create shadowing bindings"
 :valueof (mangle-binding '(withs (a (+ a 1) y 2) (= a 2) (cons a b)) 'a 'a_2)
 :should be '(withs (a (+ a_2 1) y 2) (= a 2) (cons a b)))

(test "rename-vars-in-bindings works"
 :valueof (rename-vars-in-bindings (table 'x 'x2) '(x 1 y 2))
 :should be '(x2 1 y 2))

(test "rename-vars-in-bindings ignores expressions"
 :valueof (rename-vars-in-bindings (table 'x 'x2) '(a x b y))
 :should be '(a x b y))

(test "rename-vars-in-bindings replaces later expressions"
 :valueof (rename-vars-in-bindings (table 'x 'x2)
                                   '(a x x (+ a 1) b x))
 :should be '(a x x2 (+ a 1) b x2))

(test "rename-vars-in-bindings replaces later expressions - 2"
 :valueof (rename-vars-in-bindings (table 'x 'x2) '(x (+ x 1) y x))
 :should be '(x2 (+ x 1) y x2))

(test "rename-vars-in-bindings renames multiple vars"
 :valueof (rename-vars-in-bindings (table 'x 'x2 'y 'y2)
                                   '(x (+ x 1) y x))
 :should be '(x2 (+ x 1) y2 x2))

(test "new-vars updates conflicts with gensyms"
 :valueof (withs (got (new-vars '(a b c))
                  expected  (table 'a 'a_ 'b 'b_ 'c 'c_))
            (list (iso expected got)
                  (~~match expected got)))
 :should be '(nil 1))

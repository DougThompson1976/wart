(test "len works by default"
  :valueof (len nil)
  :should be 0)

(test "len works by default - 2"
  :valueof (len '(1 2 3))
  :should be 3)

(test "len works on hash tables"
  :valueof (len (obj 1 2 3 4))
  :should be 2)



(test "iso works like equal by default"
  :valueof (iso nil nil)
  :should be t)

(wt-eval '(def iso(x y) :case (isa x 'footype)
            (and (position 3 rep.x)
                 (position 3 rep.y))))

(test "new case for iso takes"
  :valueof (annotate 'footype '(1 2 3))
  :should be (annotate 'footype '(3 4 5)))

(test "iso works by coercing empty tables"
  :valueof (table)
  :should be (table))

(test "iso works on tables"
  :valueof (obj 1 2 3 4)
  :should be (obj 3 4 1 2))

(test "iso works on characters"
  :valueof (iso #\a #\a)
  :should be t)

(test "iso works on characters - 2"
  :valueof (iso #\a #\b)
  :should be nil)

(test "iso works on non-characters"
  :valueof (iso #\tab #\tab)
  :should be t)



(test "all works"
  :valueof (all 'idfn '(1 2 3))
  :should be t)

(test "all works - 2"
  :valueof (all 'idfn '(1 nil 3))
  :should be nil)

(test "all works on strings"
  :valueof (all #\a "aaa")
  :should be t)

(test "mem works"
  :valueof (mem 'oddp '(2 4 5 6 7))
  :should be '(5 6 7))

(test "keep works"
  :valueof (keep 'oddp '(1 2 3))
  :should be '(1 3))

(test "keep works on strings"
  :valueof (keep [iso _ #\a] "abc")
  :should be "a")

(test "rem works"
  :valueof (rem 'oddp '(1 2 3))
  :should be '(2))

(test "rem works on strings"
  :valueof (rem #\a "abracadabra")
  :should be "brcdbr")

(test "trues works"
  :valueof (trues 'cdr '((1 2) (3) (4 5)))
  :should be '((2) (5)))

(test "cut works"
  :valueof (cut '(1 2 3 4) 2)
  :should be '(3 4))

(test "cut works on strings"
  :valueof (cut "abc" 1)
  :should be "bc")

(test "join still works"
  :valueof (join '(1) '(2 3))
  :should be '(1 2 3))

(test "join works on strings"
  :valueof (join "abc" "def")
  :should be "abcdef")

(test "join can handle nils, especially as last arg"
  :valueof (join nil '(3 4) nil '(5) '(6) nil)
  :should be '(3 4 5 6))

(test "join handles zero-args"
  :valueof (join)
  :should be nil)

(test "join handles all null args"
  :valueof (join nil nil nil)
  :should be nil)

(test "pos works"
  :valueof (pos 'c '(a b c d))
  :should be 2)

(test "pos works on strings"
  :valueof (pos #\c "abcd")
  :should be 2)

(test "pos takes index arg"
  :valueof (pos #\c "abcdc" 3)
  :should be 4)

(test "pos testifies"
  :valueof (pos 'oddp '(2 4 5 6 7))
  :should be 2)



(test "map works"
  :valueof (map '1+ '(2 3 4))
  :should be '(3 4 5))

(test "map works on strings"
  :valueof (map 'char-upcase "abc")
  :should be "ABC")

(test "map works on primitives"
  :valueof (map 'char-upcase #\a)
  :should be #\A)

(wt-eval '(def map(f . seqs) :case (isa car.seqs 'footype)
            (apply 'map0 f (map0 'rep seqs))))
(test "map works on user-defined types"
  :valueof (map 'len (annotate 'footype '((2 3) (3 4 4 6))))
  :should be '(2 4))



; integration test: obj + set + iso
(test "setting inside compound structures works"
  :valueof (ret aa (obj a '(1 2) b 3)
             (= aa!a.1 34))
  :should be (obj a '(1 34) b 3))

(test "compose works"
  :valueof (call 1+^1+ 3)
  :should be 5)

(test "complement works"
  :valueof (call ~oddp 3)
  :should be nil)

(test-lisp "expand-ssyntax translates ^ to compose"
  :valueof (expand-ssyntax 'a^b)
  :should be '(wart-compose a b))

(test-lisp "expand-ssyntax translates ~ to complement"
  :valueof (expand-ssyntax '~b)
  :should be '(complement* b))

(test-lisp "expand-ssyntax translates . to just a call"
  :valueof (expand-ssyntax 'a.b)
  :should be '(call a b))

(test-lisp "expand-ssyntax translates ! to just a call"
  :valueof (expand-ssyntax 'a!b)
  :should be '(call-quoted a b))

(test-lisp ". and ! are left-associative"
  :valueof (expand-ssyntax 'a.b!c.d)
  :should be '(call (call-quoted (call a b) c) d))

(test-lisp "~ has higher precedence"
  :valueof (expand-ssyntax '~testify.test)
  :should be '(complement* (call testify test)))

(test-lisp "expand numbers correctly"
  :valueof (expand-ssyntax 'a.3)
  :should be '(call a 3))

(test ". works"
  :valueof oddp.3
  :should be t)

; integration test: macros + call + ssyntax
(setf a 3)
(test ". works with macros"
  :valueof incf.a
  :should be 4)

; integration test: defover + ssyntax
(test-lisp "expand-ssyntax goes through wt-transform"
  :valueof (expand-ssyntax 'defover-foo.3)
  :should be '(call defover-bar 3))

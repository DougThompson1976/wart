(test "if handles 0 args"
 :valueof (if)
 :should be nil)

(test "if handles 1 arg"
 :valueof if.3
 :should be 3)

(test "if handles 2 args"
 :valueof (if 3 4)
 :should be 4)

(test "if handles then branch"
 :valueof (if 3 4 5)
 :should be 4)

(test "if handles else branch"
 :valueof (if nil 4 5)
 :should be 5)

(test "if handles 4 args"
 :valueof (if nil 4 5 6)
 :should be 6)

(test "if handles 5 args"
 :valueof (if nil 4 nil 6 7)
 :should be 7)

(test "if handles :else"
 :valueof (if nil 4 :else 6)
 :should be 6)

(test "if handles lexical scope"
 :valueof (let x 34 (if x))
 :should be 34)

(test "if handles dynamic scope"
 :valueof (do (= x 34)
              (if x 35))
 :should be 35)



(test "or handles 0 args"
 :valueof or.
 :should be nil)

(test "or handles nil arg"
 :valueof or.nil
 :should be nil)

(test "or handles non-nil arg"
 :valueof or.3
 :should be 3)

(test "or handles 2 args"
 :valueof (or nil 3)
 :should be 3)

(test "or handles multiple non-nil args"
 :valueof (or 3 4)
 :should be 3)

(test "or short-circuits on first non-nil arg"
 :valueof (let x nil
            (or 3 (= x 4))
            x)
 :should be nil)

(test "or evals each arg at most once"
 :valueof (let x 0
            (or (do (= x (+ x 1))
                    3)
                (do (= x (+ x 1))
                    4))
            x)
 :should be 1)

(test "or handles lexical scope"
 :valueof (do (= x 35)
              (let x 3
                (or nil x)))
 :should be 3)



(test "and handles 0 args"
 :valueof and.
 :should ~be nil)

(test "and handles nil arg"
 :valueof and.nil
 :should be nil)

(test "and handles non-nil arg"
 :valueof and.3
 :should be 3)

(test "and handles 2 args"
 :valueof (and nil 3)
 :should be nil)

(test "and handles 2 non-nil args"
 :valueof (and 3 4)
 :should be 4)

(test "and handles lexical scope"
 :valueof ((fn(x) (and 3 x 4)) nil)
 :should be nil)

(test "and short-circuits"
 :valueof (let x 0
            (and (= x 3)
                 nil
                 (= x 4))
            x)
 :should be 3)

(test "and handles dynamic scope"
 :valueof (do (= x 35)
              (and x 36))
 :should be 36)



(test "iso handles nils"
 :valueof (iso nil 3)
 :should be nil)

(test "iso compares nils"
 :valueof (iso nil nil)
 :should ~be nil)

(test "iso handles ints"
 :valueof (iso 3 4)
 :should be nil)

(test "iso handles ints - 2"
 :valueof (iso 3 3)
 :should ~be nil)

(test "iso handles strings"
 :valueof (iso "a" "b")
 :should be nil)

(test "iso handles strings - 2"
 :valueof (iso "a" "a")
 :should ~be nil)

(test "iso handles lists"
 :valueof (iso list.1 list.2)
 :should be nil)

(test "iso handles lists - 2"
 :valueof (iso list.1 list.1)
 :should ~be nil)

(test "iso handles user-defined types"
 :valueof (iso '(type foo 3) '(type foo 3))
 :should ~be nil)



(test "is-match - atom positive"
 :valueof (is-match 3 3)
 :should ~be nil)

(test "is-match - atom negative"
 :valueof (is-match 3 4)
 :should be nil)

(test "is-match - list positive"
 :valueof (is-match '(1 (2 3)) '(1 (2 3)))
 :should ~be nil)

(test "is-match - list negative"
 :valueof (is-match '(2 (2 3)) '(1 (2 3)))
 :should be nil)

(test "is-match treats _ as atom wildcard"
 :valueof (is-match '_ 3)
 :should ~be nil)

(test "is-match - _ positive"
 :valueof (is-match '(1 (_ 3 4)) '(1 (2 3 4)))
 :should ~be nil)

(test "is-match - _ negative"
 :valueof (is-match '(2 (_ 3 4)) '(1 (2 3 4)))
 :should be nil)

(test "is-match - _ matches lists"
 :valueof (is-match '_ '(3))
 :should ~be nil)

(test "is-match - _ matches lists when dotted"
 :valueof (is-match '(1 . _) '(1 2 3))
 :should ~be nil)

(test "is-match treats any sym beginning with _ as wildcard"
 :valueof (is-match '(1 . _x) '(1 2 3))
 :should ~be nil)

(test "is-match manages _sym identity"
 :valueof (is-match '(1 _x _x) '(1 2 3))
 :should be nil)

(test "is-match manages _sym identity - 2"
 :valueof (is-match '(1 _x _x) '(1 2 2))
 :should ~be nil)

(test "is-match matches $vars with their root"
 :valueof (is-match 'a_ 'a3)
 :should ~be nil)

(test "is-match matches $vars with their root - 2"
 :valueof (is-match 'a_ 'a)
 :should be nil)

(test "is-match manages $var_sym identity"
 :valueof (is-match '(a_x a_x) '(a3 a3))
 :should ~be nil)

(test "is-match manages $var_sym identity - 2"
 :valueof (is-match '(a_x a_x) '(a2 a3))
 :should be nil)

(test "is-match manages $var_sym identity - 3"
 :valueof (is-match '(a_x a_x) '(a a3))
 :should be nil)

(test "match integrates with test"
 :valueof (list 'a3 'a3)
 :should match '(a_x a_x))

 

(test "caselet works"
 :valueof (caselet x 'b
            'a
              1
            'b
              2
              3)
 :should be 2)

(test "case works"
 :valueof (with (x 1 y 2 z 3 w 2)
            (case w
              x
                34
              y
                35
              z
                36))
 :should be 35)

(test "case uses predicate"
 :valueof (let x 3
            (case x
              odd?
                34
              even?
                36))
 :should be 34)

(test "case recognizes keyword :else"
 :valueof (let x 3
            (case x
              even?
                34
              :else
                35))
 :should be 35)

(test "sym-root works"
 :valueof (sym-root 'a3)
 :should be 'a)

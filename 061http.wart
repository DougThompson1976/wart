;; http://www.arclanguage.org/item?id=11337

(def parse-http-request(ip ? from stdin*)
  (withs ((method url protocol)   (tokens read-line.from)
          (path query)  (tokens url #\?)
          headers   (parse-http-headers from)
          body  (read-body headers from))
    (obj protocol   protocol
         method   (call sym^downcase method)
         path   path
         query  query
         headers  headers
         ip   (or (alref "x-forwarded-for" headers)
                  (alref "x-real-ip" headers)
                  ip)
         cookies  (parse-http-cookies headers)
         body   body
         args   (join (parse-http-args query)
                      (parse-http-body headers body)))))

(def parse-http-headers(? from stdin*)
  (let line read-line.from
    (awhen (pos #\: line)
      (cons (cons (map 'downcase (cut line 0 it))
                  (trim (cut line 1+.it)))
            (parse-http-headers from)))))

(def parse-http-cookies(headers)
  (map [dot (tokens trim._ #\=)]
       (tokens (alref "cookie" headers) #\;)))

(def parse-http-args(args)
  (when args
    (map [dot (map 'urldecode (tokens _ #\=))]
         (tokens args #\&))))

(def parse-http-body(headers body)
  (when (search "x-www-form-urlencoded"
                (alref "content-type" headers))
    (parse-http-args body)))

(def read-body(headers ? from stdin*)
  (whenlet num (aand (alref "content-length" headers)
                     (errsafe int.it))
    (str (accum acc
           (repeat num
             (acc (read-char from)))))))

(def parse-url(url)
  (ret ans (obj protocol "http"
                host nil
                port 80
                path "/")
    (awhen (search "://" url)
      (= ans!protocol (downcase (cut url 0 it))
         url (cut url (+ it 3))))
    (aif (pos #\/ url)
       (= ans!host (cut url 0 it)
          ans!path (cut url it))
       (= ans!host url))
    (awhen (pos #\: ans!host)
      (= ans!port (int (cut ans!host 1+.it))
         ans!host (cut ans!host 0 it)))))

(def http-get(url)
  (let purl parse-url.url
    (connecting stream :to purl!host :at purl!port
      (w/stdout stream
        (prrn (join "GET " purl!path " HTTP/1.0"))
        (pr-headers (obj Host purl!host Connection "close"))
        (flush))
      (w/stdin stream
        (let (protocol status . reason)   (tokens read-line.stream)
          (obj protocol   protocol
               status   status
               reason   (intersperse " " reason)
               headers  parse-http-headers.stream
               nil  read-line.stream ; chomp newline after headers
               body   slurp.stream))))))

(def pr-headers(headers)
  (each (n v) headers
    (prrn n ": " v))
  (prrn))

(= http-ok+         "200 OK"
   http-created+    "201 Created"
   http-found+      "302 Found"
   http-notmod+     "304 Not Modified"
   http-bad+        "400 Bad Request"
   http-forbidden+  "403 Forbidden"
   http-notfound+   "404 Not Found")

(= http-headers* (obj Server "wart"
                      Content-Type "text/html"
                      Connection "closed"))

let $if if
  mac! if args
    $if ~cdr.args
      car.args
      `(,$if ,car.args
         ,cadr.args
         (if ,@cddr.args))

mac or args
  if args
    `(let $x ,car.args
       (if $x
         $x
         (or ,@cdr.args)))

mac and args
  if no.args
    1
    if ~cdr.args
      car.args
      `(if ,car.args
         (and ,@cdr.args))

let $iso iso # ignore later refinements
  def isa(x 'Type)
    ($iso Type type.x)

let $iso iso
  def! iso(a b)
    (or ($iso a b)
        (and cons?.a cons?.b   # default for objects
             (iso car.a car.b)
             (iso cdr.a cdr.b)))

mac (|=) (var val)
  `(or ,var
       (= ,var ,val))

def is_match(a b bindings)
  bindings |= (table)
  (or (iso a b)
      (iso '_ a)  # _ matches anything
      (and cons?.a cons?.b  # default for objects
           (is_match car.a car.b bindings)
           (is_match cdr.a cdr.b bindings)))

def only(f)
  (fn args
    (if f (f @args)))

mac check(x test else)
  `(let $x ,x
     (if (,test $x)
       $x
       ,else))

def maybe(f a b|to)
  if a
    (f a b)
    b

mac in(x ... choices)
  `(let $x ,x
     (or ,@(map (fn(_) `(iso $x ,_))
                choices)))

def predicate(x)
  (if
    (isa x function)
      x
    (iso x :else)
      (fn() 1)
    :else
      (fn(_) (iso x _)))

mac caselet(var expr ... branches)
  let expand (afn(branches)
               (if ~cdr.branches
                 car.branches
                 `(if ((predicate ,car.branches) ,var)
                    ,cadr.branches
                    ,(self cddr.branches))))
    `(let ,var ,expr ,expand.branches)

mac case(expr ... branches)
  `(caselet $x ,expr ,@branches)

mac acase(expr ... branches)
  `(caselet it ,expr ,@branches)

defcall list(seq idx . ends)
  withs (idx    (range_start seq idx)
         end    (if
                  !ends
                    (+ idx 1)
                  !car.ends
                    len.seq
                  :else
                    (range_bounce seq car.ends))
         slice  (list_range seq idx end))
    if ends
      slice
      car.slice

defset list((seq idx . ends) val)
  `(withs ($idx (range_start ,seq ,idx)
           $end ,(if !ends
                   `(+ $idx 1)
                   `(if !,car.ends
                      len.,seq
                      (range_bounce ,seq ,car.ends))))
     ,(if ends
        `(list_splice ,seq $idx $end ,val)
        `(car:list_splice ,seq $idx $end list.,val)))

def pos(x seq n)
  |= n 0
  if seq
    if (iso x car.seq)
      n
      (pos x cdr.seq (+ n 1))

def rpos(x seq n)
  aif (pos x rev.seq n)
    (- len.seq 1 it)

def predicate(x) :case list?.x
  (fn(_) (pos _ x))

def_assign car(seq x)
  (set_car seq x)

def_assign cdr(seq x)
  (set_cdr seq x)

def empty?(seq)
  nil?.seq

def blank?(seq)
  (or nil?.seq empty?.seq)

def copy(x)
  if cons?.x  ; piecewise copy for objects by default
    (cons copy:car.x copy:cdr.x)
    x

def single?(x)
  (and list?.x ~cdr.x)

def pair?(x)
  (and list?.x
       cdr.x
       list?:cdr.x
       ~cdr:cdr.x)

def rev(seq acc)
  if !seq
    acc
    (rev cdr.seq
         (cons car.seq acc))

def lastcons(seq)
  aif cdr.seq
    lastcons.it
    seq

def last(seq)
  car:lastcons.seq



def zip(a b)
  if (and a b)
    (cons (list car.a car.b)
          (zip cdr.a cdr.b))

def zipmax(a b)
  if (or a b)
    (cons (list car.a car.b)
          (zipmax cdr.a cdr.b))

def zip_flat(a b)
  if (and a b)
    `(,car.a ,car.b ,@(zip_flat cdr.a cdr.b))

def flatten(seq acc)
  (if
    !seq
      acc
    ~list?.seq
      (cons seq acc)
    :else
      (flatten car.seq (flatten cdr.seq acc)))



def join args
  if args
    if car.args
      (cons car:car.args
            (join cdr:car.args @cdr.args))
      (join @cdr.args)

def keep(f seq)
  if seq
    if f:car.seq
      (cons car.seq (keep f cdr.seq))
      (keep f cdr.seq)

def rem(f seq)
  (keep complement:predicate.f seq)
alias skip rem

def some(f seq)
  (or @(map f seq))

def all(f seq)
  (and @(map f seq))

alias any some
alias none ~some



def map(f . seqs) :case cdr.seqs
  if (all present? seqs)
    (cons (f @(map car seqs))
          (map f @(map cdr seqs)))

def reduce(f seq init)  ; f is a binary op
  (if
    !seq
      init
    ~cdr.seq
      car.seq   ; f on one op is the identity function
    :else
      (reduce f (cons (f car.seq cadr.seq)
                      cddr.seq)))

def pairwise(seq)
  (zip seq cdr.seq)

def best(f seq)
  if seq
    ret winner car.seq
      each elem cdr.seq
        if (f elem winner)
          = winner elem



;; Internals

def range_bounce(seq idx)
  if (< idx 0)
    (+ len.seq idx)
    idx

def range_start(seq idx)
  if !idx
    0
    (range_bounce seq idx)

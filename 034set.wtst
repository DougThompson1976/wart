(test "set works"
  :valueof (let x nil
             (set x)
             x)
  :should be t)

(test "wipe works"
  :valueof (let x 34
             (wipe x)
             x)
  :should be nil)

(test "wipe works for multiple args"
  :valueof (do (wipe x y z) (list x y z))
  :should be '(nil nil nil))

(test "swap works"
  :valueof (with (a 3 b 4) (swap a b) (cons a b))
  :should be '(4 . 3))

(test "rotate works"
  :valueof (with (a 3 b 4 c 5) (rotate a b c) (list a b c))
  :should be '(4 5 3))

(wt-eval '(mac pull(f seq)
            `(zap [remove-if ,f _] ,seq)))
(test "zap works"
  :valueof (let x '(1 100 2 50 3) (pull [< _ 10] x) x)
  :should be '(100 50))

(test "collect works"
  :valueof (collect (map0 [yield (* _ 10)] '(1 2 3)))
  :should be '(10 20 30))

(wt-eval '(def fooyield(_) (yield (* _ 10))))
(test "collect can yield from deep inside the call hierarchy"
  :valueof (collect (map0 #'fooyield '(1 2 3)))
  :should be '(10 20 30))

(test "collect/yield can nest"
  :valueof (collect (yield (collect (yield 1))))
  :should be '((1)))

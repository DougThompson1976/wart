(test-wart "compose works"
  :valueof (call 1+^1+ 3)
  :should be 5)

(test-wart "complement works"
  :valueof (call ~oddp 3)
  :should be nil)

(test "expand-ssyntax translates ^ to compose"
  :valueof (expand-ssyntax 'a^b)
  :should be '(compose* a b))

(test "expand-ssyntax translates ~ to complement"
  :valueof (expand-ssyntax '~b)
  :should be '(complement* b))

(test "expand-ssyntax translates . to just a call"
  :valueof (expand-ssyntax 'a.b)
  :should be '(call* a b))

(test "expand-ssyntax translates ! to just a call"
  :valueof (expand-ssyntax 'a!b)
  :should be '(call*-quoted a b))

(test ". and ! are left-associative"
  :valueof (expand-ssyntax 'a.b!c.d)
  :should be '(call* (call*-quoted (call* a b) c) d))

(test "expand numbers correctly"
  :valueof (expand-ssyntax 'a.3)
  :should be '(call* a 3))

(test-wart ". works"
  :valueof oddp.3
  :should be t)

(defmacro macfoo(a) `(+ 1 ,a))
(test-wart "call* handles macros"
  :valueof (call* macfoo 3)
  :should be 4)

(test-wart "call* works"
  :valueof (call* oddp 3)
  :should be t)

(setf a 2)
(test-wart "call* handles macros with global bindings"
  :valueof (call* macfoo a)
  :should be 3)

(test-wart "call* handles macros with bindings"
  :valueof (_let a 3 (call* macfoo a))
  :should be 4)

(test-wart "call* handles incf macro"
  :valueof (_let a 32 (call* incf a))
  :should be 33)

; integration test: nested calls
(test-wart "call* nests"
  :valueof (macex '(call* (call* a 3) 4))
  :should be '(call (call* a 3) 4))

; integration test: macros + call + ssyntax
(setf a 3)
(test-wart ". works with macros"
  :valueof incf.a
  :should be 4)

; integration test: defover + ssyntax
(test "expand-ssyntax goes through wt-transform"
  :valueof (expand-ssyntax 'defover-foo.3)
  :should be '(call* defover-bar 3))

(test "call* expands compositions"
  :valueof (macex1 '(call* (compose* incf foo) x))
  :should be '(incf (call* foo x)))

;; Primitives for binding variables

(mac wart-map(f . seqs)
  `(map 'list ,f ,@seqs)) ; recursive map won't be transformed
(defover map wart-map)

(mac with(parms . body)
  `(call (fn ,(map #'car pair.parms)
           ,@body)
         ,@(map #'cadr pair.parms)))

(mac wart-let(var val . body)
  `(with (,var ,val) ,@body))
(defover let wart-let)

(mac ret(var val . body)
  `(let ,var ,val ,@body ,var))

(mac withs(parms . body)
  (if (no parms)
      `(do ,@body)
      `(let ,(car parms) ,(cadr parms)
         (withs ,(cddr parms) ,@body))))

(def pair(xs ? f #'list)
  (if (no xs)   nil
      (no cdr.xs)   (call list^list car.xs)
      (cons (call f car.xs cadr.xs)
            (pair cddr.xs f))))

(def isa(elem typ)
  (is typ type.elem))

(mac w/uniq(names . body)
  (if (consp names)
      `(with ,(apply #'join nil (map [list _ '(uniq)]
                                     names))
         ,@body)
      `(let ,names (uniq) ,@body)))
